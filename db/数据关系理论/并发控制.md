**并发控制保证[事务](数据安全性.md)的隔离性和一致性**. 数据库中, 并发控制通过三种手段实现: **锁, 时间戳和快照隔离**.

并发中数据不一致性:
1. **丢失修改**: 事务 T1 和事务 T2 读入同一数据并修改, 修改冲突导致一方修改丢失.
2. **读脏数据**: T1 读取数据后, 该数据失效. 如 T2 之前修改过该数据, 在 T1  读取后, T2 之前的修改被撤销了, 导致 T1 已读取的数据失效.
3. **不可重复读**: T1 前后两次读取某一项数据期间, T2 更新了数据, 导致 T1 两次读取时结果不一致.

数据库事务的隔离级别定义:
1. 可串行化: 理想情况, 所有事务的并发操作等价于[串行操作](../../netsec/软件安全/并发安全/happens%20before.md).
2. 可重复读: 只允许读取已提交的数据. 并且, 在同一个事务读取同一项数据期间, 其他事务不允许更新该数据项.
3. 已提交读: 只允许读取已提交的数据. 但同一事务读取同一项数据期间, 其他事务允许更改该数据项并提交.
4. 未提交读: 允许读取其他事务未提交的数据, 但不能写入其未提交数据. 由于其他事务随后可能回滚, 因此存在*读脏数据*. 是最低隔离性要求.

| 隔离级别         |  丢失修改   | 脏读 | 不可重复读 | 幻读[^1] | 实现方法 |
| ---------------- | --- | ---- | ---------- | -------- | -------- |
| Read Uncommitted |  N   | Y    | Y          | Y        | ...      |
| Read Committed   |  N   | N    | Y          | Y        |          |
| Repeatable Read  |  N   | N    | N          | Y        |          |
| Serializable     |  N   | N    | N          | N        |          |


## 基础锁

读写锁详见 [进程同步与互斥](../../os/进程调度/进程同步与互斥.md)

### X 锁

X 锁, 又被称为*排他锁, 写锁*. 若事务 T 对数据 A 加上 X 锁, 则只允许 T 读取和修改 A. 在 T 释放 A 上的 X 锁之前, 其他事务不能读取和修改 A, 并且不能再对 A 加任何类型的锁.

### S 锁

S 锁, 又称*共享锁, 读锁*. 若事务 T 对数据 A 加上 S 锁, 则 T 可以读取 A, 但是不能修改 A. 在 T 释放 A 上的 S 锁之前, 其他事务可以读取 A, 可以对 A 加 S 锁, 但是不能修改 A, 也不能对 A 加 X 锁.

### 三级封锁协议

1. 一级封锁协议: 事务修改数据时, 必须先加 X 锁, 直到事务结束才释放.
2. 二级封锁协议: 事务修改数据时, 必须先加 X 锁 (一级协议); 并且其他事务在读取数据前, 必须先对其加 S 锁, **读完后**即可释放 S 锁.
3. 三级封锁协议: 事务修改数据时, 必须先加 X 锁 (一级协议); 并且其他事务在读取数据前, 必须先对其加 S 锁, 直到**事务结束**才释放 S 锁.

<table>
<tr>
	<th></th>
	<th colspan="2">X 锁</th>
	<th colspan="2">S 锁</th>
	<th colspan="3">一致性保证</th>
</tr>
<tr>
	<th></th>
	<th>操作结束释放</th>
	<th>事务结束释放</th>
	<th>操作结束释放</th>
	<th>事务结束释放</th>
	<th>不丢失修改</th>
	<th>不读脏数据</th>
	<th>可重复读</th>
</tr>
<tr>
	<td>一级封锁协议</th> <td></td> <td>Y</td> <td></td> <td></td> <td>Y</td> <td></td> <td></td>
</tr>
<tr>
	<td>二级封锁协议</th> <td></td> <td>Y</td> <td>Y</td> <td></td> <td>Y</td> <td>Y</td> <td></td>
</tr>
<tr>
	<td>三级封锁协议</th> <td></td> <td>Y</td> <td></td> <td>Y</td> <td>Y</td> <td>Y</td> <td>Y</td>
</tr>
</table>

## 死锁与活锁

### 活锁

当系统不采用先来先服务策略时, 权重低的事务可能一直在等待资源, 造成活锁.

```
资源     优先队列
R   <-  T1, T2
R   <-  T3, T2
R   <-  T4, T2
...
T2 始终等待 R
```

### 死锁

循环等待资源, 造成死锁. 详见 [进程同步与互斥](../../os/进程调度/进程同步与互斥.md)

## 串行化调度

一个给定并发调度, 当且仅当它是*可串行化的*, 才认为其是正确调度.

### 两段锁协议

2PL
1. 扩展阶段: 对任何数据*读和写*之前, 事务先对其封锁.
2. 收缩阶段: 释放一个封锁后, 事务不再申请和获得任何其他锁.

遵循 2PL 协议并发执行的事务, 则其可串行化.

## 意向锁

加锁粒度树: 加锁粒度越细, 系统并发性越高, 但效率越低 (开销越大).

```
 database
|        \
关系R1     关系R2
|    \       |    \
元组...元组   元组...元组
```

如果对一个节点加意向锁, 说明该节点的下层节点正在被加锁. 意向锁 (intention lock) 可以提高数据对象加锁时系统的检查效率, 因为系统不用再向下层扫描. 引入意向锁后, 申请封锁自粒度树上而下进行, 释放封锁自下而上进行.

- 意向共享锁, Intent Share Lock, IS: 下层节点拟加 S 锁
- 意向排他锁, Intent Exclusive Lock, IX: 下层节点拟加 X 锁.
- 共享意向排他锁, Share Intent Exclusive Lock, SIX: 先加 S 锁, 再加 IX 锁.

锁相容矩阵:

| v 已获得锁 > 要加的锁 | S   | X   | IS  | IX  | SIX |
| --------------------- | --- | --- | --- | --- | --- |
| S                     | Y   | N   | Y   | N   | N   |
| X                     | N   | N   | N   | N   | N   |
| IS                    | Y   | N   | Y   | Y   | Y   |
| IX                    | N   | N   | Y   | Y   | N   |
| SIX                   | N   | N   | Y   | N   | N    |

锁强度: $X>SIX> S\simeq IX >IS$

[^1]: 幻读, 是不可重复读的一种特殊情况. 不可重复度加行级锁, 但幻读更麻烦, 一般要给整个表加锁.