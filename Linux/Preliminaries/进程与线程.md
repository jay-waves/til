## 进程

**进程的定义:** 一个程序在一个数据集上的一次执行.  
注意区分程序和进程, 程序是**静态**存储在磁盘上的可执行文件, 进程是**动态**保存在内存中的程序的一次执行过程.

#### 内存中结构

- 代码段, Text, 存放指令序列
- 数据段, Data, 全局变量和静态变量
- 堆栈段, 栈一般又编译器自动分配, 堆则由程序员动态分配.

![|150](../../attach/Pasted%20image%2020230619171849.png)

进程控制块, PCB, Process Control Block. 主要内容有**PID, 进程状态, 资源分配信息**. PCB存放在单独内存区域内.

![|150](../../attach/Pasted%20image%2020230619172853.png)

#### 进程五状态

- 新建态, new. OS分配资源, 初始化PCB.
- 就绪态, ready. 进程等待分配处理机.
- 运行态, running. 占用处理机, 执行指令.
- 阻塞态, waiting, 等待态. 进程因等待资源或事件而暂停.
- 终止态, terminated. 执行完毕, OS回收资源, 撤销PCB.

![|400](../../attach/Pasted%20image%2020230619205635.png)

这里的运行, 仅指"占有CPU运行". Linux中, 数据结构分为一个就绪队列和多个阻塞队列 (对应多个事件). 

#### 进程的创建, 终止, 唤醒, 切换, 阻塞

1. `ps` 查看进程
2. `pstree` 查看进程树. linux初始进程是init

`fork()`系统调用, 调用一次, 返回两次. 用于创建父进程的完整副本.
返回值用于区分父子进程, 父进程返回新建子进程id, 子进程返回0, 出错返回-1.

`clone()`调用, 创建轻量级**线程**, 有选择地继承父进程资源.

![|500](../../attach/Pasted%20image%2020230619181858.png)

`exec()`系统调用, 将进程替换为新程序的进程.

`exit()`系统调用, 中止进程. 

`wait()`, `waitpid()`系统调用, 父进程等待子进程执行结束, 并获取其返回值.

![|300](../../attach/Pasted%20image%2020230619182508.png)

进程唤醒指将进程**从阻塞态变为就绪态**, 切换则指**就绪态和运行态的转换.** [操作系统并发](操作系统概述.md)需要**进程上下文切换 (Context Switch):**

![|400](../../attach/Pasted%20image%2020230619183343.png)

## 线程

==进程是资源分配的基本单位, (内核级)线程是CPU调度的基本单位==.  
**线程定义:** CPU使用的基本单元, 包括(线程ID, 程序计数器, 寄存器组和堆栈). 同一进程的各个线程间也可以并发, 进一步提高并发度.

线程控制块, Tread Control Block, TCB.  
- 线程ID
- 线程状态
- 程序计数器PC
- 寄存器集
- 栈空间

线程不拥有完整的系统资源, 通过进程申请资源. 同进程的多个线程共享代码段, 数据段和某些系统资源.

![|400](../../attach/Pasted%20image%2020230619203020.png)

#### 多线程优势

1. 响应度高
2. 资源共享: 线程共享同属进程的内存和资源, 同地址空间可有多个线程.
3. 经济性: 线程创建与上下文切换更经济.
4. 可伸缩性: 并行运行

#### 多线程实现模型

多对一模型: 指用户线程, 线程在用户空间管理, 内核只支持进程. 线程切换无需内核参与, 但线程无法并发, 单线程阻塞会导致整体阻塞.

![|150](../../attach/Pasted%20image%2020230619203728.png)

一对一模型: 并发性好, 但内核模式切换开销较大.

![|150](../../attach/Pasted%20image%2020230619203732.png)

多对多模型: 这里用户线程指"代码逻辑", 而内核线程则指"运行机会"

![|150](../../attach/Pasted%20image%2020230619203736.png)