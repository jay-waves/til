**功能:**  
- 内存空间的分配和回收
- 内存空间的扩充
	- 覆盖技术
	- 交换技术
	- 虚拟内存技术
- 地址转换
	- 编译时转换, 适用于单道程序系统
	- 装入时转换, 静态重定位. 一次装入全部内存空间, 此后无法改变, 多用户难以共享.
	- 运行时转换, 动态重定位. 特定硬件对地址映射支持, 可分配到不连续内存空间, 运行时再进行地址转换.
- 存储保护: 检查地址: $base \leq addr \lt base+limit$

**程序编译**过程: 

源程序 --(编译器/汇编器)--> 目标模块 --(链接器, 建立静态链接)--> 装入模块 (即exe) --(装入器, 建立装入时动态链接)-->(二进制内存映射, 建立运行时动态链接)

1. 静态链接: 编译时就将库函数全部编译入可执行文件中. (linux 中 `libxxx.a`, windows中的 `xxx.lib`)
2. 动态链接: 编译时, 只在可执行文件中保存指向库函数的链接, 库函数仅由操作系统维护同一的一份 (Linux的\*.os, Windows的\*.ddl) 
	- 装入时动态链接: 仅装入内存时加载引用库.
	- 运行时动态链接: 允许程序在执行时链接到新的库, 或取消对已有库的链接.

## 内存分配

- 外碎片: 内存中空闲分区太小, 而难以利用
- 内碎片: 分配给进程的内存区域, 进程实际未使用

### 连续内存分配

- 单一连续分配
- 固定分区分配, 优点类似分段内存管理
- 动态分区分配, 需维护*空闲分区表*

### 离散内存分配

离散内存管理可通过**地址转换**, 使程序"独享"地址空间, 称为逻辑地址. MMU负责将逻辑地址转换为实际物理地址. 由于程序一般不使用全部地址空间, 只是图编程方便, 所以物理空间可以跑多道程序.

#### 1 分页内存管理

将物理内存分为等长块, 称为**页框 Frame**, 逻辑内存也分为同样长的块, 称为**页面 Page**. 以页框为单位为进程分配内存, 不会产生外碎片 (有内碎片).

OS维护**空闲页框表**, 负责管理物理内存空闲页框. 维护**页表**, 记录页面与页框的映射关系.

![|100](../../attach/Pasted%20image%2020230620195945.png)

假设逻辑空间大小为 $2^m$ 字节, 页大小为 $2^n$ 字节. 则可以通过截取地址, 来区分页面号和业内偏移:

![|300](../../attach/Pasted%20image%2020230620200145.png)

分页的地址转化过程: 

![|500](../../attach/Pasted%20image%2020230620200358.png)

注意, 若页表在内存中, 则过程需要两次访存. 关于页表位置, 有页表基址寄存器(PTBR), 和页表限长寄存器(PRLR). PRLR用于检查页面号是否越界.

引入块表 (转化表缓冲区, TLB), 保存在CPU高速缓存中, 查找速度更快:

![|400](../../attach/Pasted%20image%2020230620201111.png)

为评价TLB效率, 引入**有效访问时间 EAT**:

$\text{EAT}=\lambda(a+b)+(1-\lambda)(a+2b)$. 其中查找TLB时间为a, 内存存取时间为b, 命中率为 $\lambda$.

分级页表: 32位系统对于每个进程都要存4MB页表, 占用大量**连续**内存, 大部分页表项是无用的. 因此衍生出多级页表.

![|450](../../attach/Pasted%20image%2020230620201852.png)

倒置页表: 页表顺序是真实物理地址顺序, 整个系统就只有一张页表, 但查表时间更长 (正常页表可以直接定位).

![|350](../../attach/Pasted%20image%2020230620203850.png)

#### 2 分段内存管理

更符合编程逻辑习惯, 对用户可见性更高. 更容易实现内存共享.

![|400](../../attach/Pasted%20image%2020230621084545.png)

地址转换过程: 

过程有两次越界检查, 一次是段内偏移是否超过段长, 一次是段号是否超过段表限长. 而分页式不用检查段内偏移, 因为按 $2^n$ 分页, 地址低n位自动变为段内偏移; 但分段式的段长 (limit) 不定, 所以需要再检查.

![|400](../../attach/Pasted%20image%2020230621083436.png)

