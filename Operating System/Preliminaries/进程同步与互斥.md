进程同步: 并发导致程序异步性, 但多个进程存在逻辑上顺序, 需要调整其工作次序.

进程互斥: 临界资源需要互斥访问. 须遵循以下原则:
- 空闲让进
- 忙则等待
- 有限等待: 有限时间能进入临界区, 防止饥饿.
- 让权等待: 进入不了临界区的进程, 需要释放CPU, 防止忙等.

## 信号量机制

### 0 信号量实现

- 整数型信号量实现:

该法缺点是不满足"让权等待", 阻塞队列会一直执行`while`, 占用CPU.
```c
wait(S) {
	while (S <= 0); //busy wait
	S--;
}

signal(S){
	S++;
}
```

- 记录型信号量
```c
typedef struct{
	int value; //资源计数
	struct process *L; //阻塞队列
} semaphore;

wait(semaphore S) {
	S.value--;
	if (S.value < 0){
		block(S.L);
	}
}

signal(semaphore S){
	S.value++;
	if (S.value <= 0){
		wakeup(S.L);
	}
}
```

### 1 进程互斥

用S实现对临界资源的互斥访问. P和V操作必须成对出现, 信号量初值设为资源数.

```c
semaphore mutex=n;
wait(mutex); //进入区, 申请信号量
CriticalSection(); //临界区
signal(mutex); //退出区, 释放信号量
```

### 2 进程同步

保证代码执行顺序, 前V后P, 信号量初始为0.

```c
semaphore S=0; //用于保证C1比C2先运行.
P1{
	C1;
	signal(S);
}

P2{
	wait(S);
	C2;
}
```

对于复杂拓扑关系, 要为每一个前驱关系都设置一个同步信号量. 

复用同步和互斥信号量时, 需要将同步P放在互斥P前, 防止达成"占有并等待"的死锁条件.

## 死锁 deadlock

死锁指多个进程循环等待对方占有的资源, 其主要成因有==竞争系统资源, 进程推进不当==. 

| 名称   | 进程数量     | 进程状态       | 成因                 |
| ------ | ------------ | -------------- | -------------------- |
| 死锁   | 至少两个进程 | 阻塞态         | OS分配资源策略不合理 |
| 饥饿   | 可能为一     | 阻塞态, 就绪态 | OS分配资源策略不合理 |
| 死循环 | 可能为一     | 运行态         | 代码逻辑错误                     |

死锁的**必要条件**为: (必须同时成立)
- 互斥
- 占有并等待
- 非抢占
- 循环等待

### 死锁的处理策略

- 预防死锁, 使死锁必要条件至少其一不成立
- 避免死锁
- 已死锁, 死锁检测
- 忽略死锁 (Linux和Windows大多采用)

#### 1 预防死锁

- 打破互斥
- 静态资源分配, *使进程申请资源时不占有其他资源*. 如, 一次性申请所有资源, 或没有(占有)资源时才能申请.
- 抢占已有资源. 如, 未申请成功进程释放其所有资源, 或允许部分资源被抢占.
- 为所有资源预先编号, 并规定封锁排序, 所有事务按顺序申请封锁.

#### 2 避免死锁

通过以后如何申请资源的额外信息, 决定是否分配资源. 最简单的策略是, ==进程声明每种资源可能用的最大数量, 据其动态检查资源分配情况, 以确保循环等待条件不成立==

如果分配资源的进程序列存在一个**安全序列**, 则系统处于**安全状态**. 安全序列定义为, 对进程序列 $<P_1, P_2, \cdots, P_n>$, 每个 $P_i$ 仍可申请的资源数不超过当前可用资源加上所有前序序列 $P_j$ 所持有的资源. 如果 $P_i$ 无法马上获得资源, 那么它等待所有前序 $P_j$ 结束返回资源.

非安全状态不一定是死锁, 但安全状态不会死锁: 
![|200](../../attach/Pasted%20image%2020230620175908.png)
