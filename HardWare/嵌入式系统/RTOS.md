RTOS 一般指 及时 (Real-Time) 的嵌入式操作系统, 特点是 简单, 高响应度.

一般的 RTOS 由几部分构成:
- Task/Thread: 任务调度, 大部分采用*优先级抢占调度*和*同优先级时间片轮转调度*. 每个任务有独立的 TCB (Task Control Block) 和栈. 
- ISR: 中断服务程序. 尽快返回原则, 不能阻塞. 不会创建自己独立的栈, 而是依附于当前栈 (或特殊的共享栈). 
- Communication (IPC): 任务间通信. 一般采用消息队列 + 信号量 + 互斥锁.
- Hardware Drivers: 硬件驱动. 

RTOS 的所有任务运行在同一个特权级和地址空间, 其实是同一个进程的不同线程. **所有全局对象都是共享的, 但是 RTOS 在不同的栈上运行它们.** RTOS 任务不是"尽快返回"的中断处理函数, 而是一个循环阻塞等待的 IO Loop.

RTOS ISR 不一定立刻唤醒 Task, 但通常会产生数据或事件, 通过 RTOS IPC 机制异步传递给 Task. 只有 RTOS 调度器能决定是否唤醒 Task: 当 ISR 通过 IPC 触发了一个更高优先级的任务, ISR 结束后, 调度器就会切换到该任务中.

RTOS 的任务通常不假设自身有原子性, 可能会重入和被抢占. 使用信号量和互斥锁 (临界区, 或递归互斥锁) 来保护共享数据; 同时, 为避免低优先级任务加锁导致高优先级任务实际阻塞, RTOS 一般支持*优先级继承*机制.

## 外设抽象

RTOS 强制依赖 **定时器中断 (systick)**, 但是不强制抽象外设. RTOS 提供一些驱动更上层的 API, 比如 ISR 注册接口 / IO 接口.
- FreeRTOS: 不包含硬件驱动, 硬件应直接访问厂商的 HAL 库 (STM HAL, Nordic SDK)
- RT-Thread: 只抽象片上串口 (UART, I2C, SPI 等), 提供 API 而不必访问控制寄存器
- Zephyr: Linux 基金会的项目. 有完整 *设备树 (Device Tree)* 和驱动模型.
- VxWorks: 商业 RTOS, 有较完整的驱动.