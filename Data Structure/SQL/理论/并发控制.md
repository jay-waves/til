**并发控制保证[事务](数据恢复.md)的隔离性和一致性**

并发中数据不一致性:
1. **丢失修改**: 事务 T1 和事务 T2 读入同一数据并修改, 修改冲突导致一方修改丢失.
2. **不可重复读**: T1 读取数据后, T2 更新了数据, 导致 T1 无法再现上一次读取结果.
3. **读脏数据**: T1 读取数据后, 该数据失效. 如 T2 之前修改过该数据, 在 T1  读取后, T2 之前的修改被撤销了, 导致 T1 已读取的数据失效.

## 基础锁

### X锁

X 锁, 又被称为*排他锁, 写锁*. 若事务 T 对数据 A 加上 X 锁, 则只允许 T 读取和修改 A. 在 T 释放 A 上的 X 锁之前, 其他事务不能读取和修改 A, 并且不能再对 A 加任何类型的锁.

### S锁

S 锁, 又称*共享锁, 读锁*. 若事务 T 对数据 A 加上 S 锁, 则 T 可以读取 A, 但是不能修改 A. 在 T 释放 A 上的 S 锁之前, 其他事务可以读取 A, 可以对 A 加 S 锁, 但是不能修改 A, 也不能对 A 加 X 锁.

### 三级封锁协议

1. 一级封锁协议: 事务修改数据时, 必须先加 X 锁, 直到事务结束才释放.
2. 二级封锁协议: 事务修改数据时, 必须先加 X 锁 (一级协议); 并且其他事务在读取数据前, 必须先对其加 S 锁, **读完后**即可释放 S 锁.
3. 三级封锁协议: 事务修改数据时, 必须先加 X 锁 (一级协议); 并且其他事务在读取数据前, 必须先对其加 S 锁, 直到**事务结束**才释放 S 锁.

<table>
<tr>
	<th></th>
	<th colspan="2">X 锁</th>
	<th colspan="2">S 锁</th>
	<th colspan="3">一致性保证</th>
</tr>
<tr>
	<th></th>
	<th>操作结束释放</th>
	<th>事务结束释放</th>
	<th>操作结束释放</th>
	<th>事务结束释放</th>
	<th>不丢失修改</th>
	<th>不读脏数据</th>
	<th>可重复读</th>
</tr>
<tr>
	<td>一级封锁协议</th> <td></td> <td>Y</td> <td></td> <td></td> <td>Y</td> <td></td> <td></td>
</tr>
<tr>
	<td>二级封锁协议</th> <td></td> <td>Y</td> <td>Y</td> <td></td> <td>Y</td> <td>Y</td> <td></td>
</tr>
<tr>
	<td>三级封锁协议</th> <td></td> <td>Y</td> <td></td> <td>Y</td> <td>Y</td> <td>Y</td> <td>Y</td>
</tr>
</table>

## 死锁与活锁

### 活锁

当系统不采用先来先服务策略时, 权重低的事务可能一直在等待资源, 造成活锁.

```
资源     优先队列
R   <-  T1, T2
R   <-  T3, T2
R   <-  T4, T2
...
T2 始终等待 R
```

### 死锁

循环等待资源, 造成死锁. 详见 [OS:进程同步与互斥](../../../System/Linux%20Basic/进程同步与互斥.md)

## 串行化调度

一个给定并发调度, 当且仅当它是*可串行化的*, 才认为其是正确调度.

### 两段锁协议

2PL
1. 扩展阶段: 对任何数据*读和写*之前, 事务先对其封锁.
2. 收缩阶段: 释放一个封锁后, 事务不再申请和获得任何其他锁.

遵循 2PL 协议并发执行的事务, 则其可串行化.

## 意向锁

加锁粒度树: 加锁粒度越细, 系统并发性越高, 但效率越低 (开销越大).

```
 database
|        \
关系R1     关系R2
|    \       |    \
元组...元组   元组...元组
```

如果对一个节点加意向锁, 说明该节点的下层节点正在被加锁. 意向锁 (intention lock) 可以提高数据对象加锁时系统的检查效率, 因为系统不用再向下层扫描. 引入意向锁后, 申请封锁自粒度树上而下进行, 释放封锁自下而上进行.

- 意向共享锁, Intent Share Lock, IS: 下层节点拟加S锁
- 意向排他锁, Intent Exclusive Lock, IX: 下层节点拟加X锁.
- 共享意向排他锁, Share Intent Exclusive Lock, SIX: 先加S锁, 再加IX锁.

锁相容矩阵:

| v 已获得锁 > 要加的锁 | S   | X   | IS  | IX  | SIX |
| --------------------- | --- | --- | --- | --- | --- |
| S                     | Y   | N   | Y   | N   | N   |
| X                     | N   | N   | N   | N   | N   |
| IS                    | Y   | N   | Y   | Y   | Y   |
| IX                    | N   | N   | Y   | Y   | N   |
| SIX                   | N   | N   | Y   | N   | N    |

锁强度: $X>SIX> S\simeq IX >IS$
