**单向散列函数** (one-way hash function) 是指对不同的输入值, 通过单向散列函数进行计算, 得到固定长度的输出值. ==其安全目标是保证**数据完整性**.==

单向散列函数也被称为**消息摘要函数**（message digest function）, **哈希函数**或者**杂凑函数**. 输入的消息也称为**原像** (pre-image). 输出的散列值也称为**消息摘要** (message digest) 或者**指纹** (fingerprint), 相当于该消息的身份证.


## 杂凑函数安全需求

| 需求                        | 描述                                                       |
| --------------------------- | ---------------------------------------------------------- |
| 输入长度可变                |                                                            |
| 输出长度固定                |                                                            |
| 效率高                      | 函数实现容易, 速度快 (实际上比对称加密还快)                |
| 单向性 (抗原像攻击)         | 任意给定hash(y), 找到y满足`Hash(y)=y`计算不可行                  |
| 抗弱碰撞性 (抗第二原像攻击) | 任意给定x, 找到y满足`Hash(y)=Hash(x)`计算不可行 |
| 抗强碰撞性 (抗碰撞攻击)   | 找出任意(x,y), 使得`Hash(x)=Hash(y)`计算不可行, $x\neq y$         |
| 伪随机性                    |                                                            |

![|350](../../../attach/密码学_哈希三种攻击类型.png)  
抗强碰撞性, 预示着也抗弱碰撞性.

哈希函数常见攻击方法是[生日攻击](生日攻击.md)

#### Q: 输出长度为什么固定?

1. 便于存储和管理, 有一致性和兼容性
2. 固定长度安全性较高. 如果输出长度可变, 一是敌手可能通过输出长度预测输入; 二是敌手会针对较短的输出进行攻击, 增加了碰撞攻击威胁. 统一长度, 也便于对其安全性进行分析.
3. 传统杂凑函数使用 [Merkel-Damgard 结构](迭代型散列函数.md), 每轮压缩函数 $f$是定长的, 方便进行迭代.

事实上, 基于海绵结构的SHA3可实现输出长度的改变, 但那是另一种密码学原语: [Extendable Output Function](https://crypto.stackexchange.com/questions/54248/what-is-an-extendable-output-function). 要改变输出长度, 还可以使用[不同链接模式](../分组密码/链接模式.md).

## 常见算法

SHA-1: 现已不再安全  
SHA-2: SHA-256 (SM3与sha256极类似), SHA-384, SHA-512  
SHA-3: 海绵结构

| 算法    | 消息长度/b | 分组长度/b | 字长度/b | 消息摘要长度/b |
| ------- | ---------- | ---------- | -------- | -------------- |
| [SHA-1](SHA-1.md)   | $<2^{64}$  | 512        | 32       | 160            |
| [SHA-256](SHA-256.md) | $<2^{64}$  | 512        | 32       | 256            |
| SHA-384 | $<2^{128}$ | 1024       | 64       | 384            |
| SHA-512 | $<2^{128}$ | 1024       | 64       | 512            |
|  [MD-5](MD-5.md)    | 无限制     | 512        | 32       | 128            |
|  [SM-3](SM-3.md)    | $<2^{64}$  | 512        | 32       | 256               |

> 消息长度限制是由于填充过程中对消息长度值所占位数进行了限定.

## 构造方法

### 1 基于迭代型散列函数

基于[迭代型散列函数结构](迭代型散列函数.md), 将数据分为大小固定的块, 分块进行处理压缩.

SHA1, MD5 是第一代安全散列算法的代表, 基于 Merkle-Damgard 迭代结构. 但这两个算法现在已不再安全.

SHA-2 系列散列函数是第二代安全散列算法, 它们仍基于Merkle-Damgard结构, 做出了一些安全性改进. (比如消息扩展为更多字, 压缩函数更复杂, 轮数更多, 增加输出变换等) 但仍被担心会像 MD5/SHA1 一样, 存在未知安全漏洞.

### 2 基于海绵结构

SHA-3 ([Keccak算法](https://keccak.team/files/CSF-0.1.pdf)) 使用该结构, 是第三代安全散列算法.
![](../../../attach/密码学_SHA3哈希函数.png)

## 应用场景

单向散列函数仅保证信息完整性

#### 1 单向(one-way) 口令

设置密码时, 服务器不记录密码本身, 只记录密码散列值. 则数据库没有泄露风险.

为了预防彩虹表 (Rainbow Table), 通常向原始数据中[加盐 (salted hash)](消息认证码/MAC.md)

> 彩虹表攻击, 就是提前针对可能的输入计算输出值, 然后在输出值中查找*截获的用户hash值*.  针对密钥等简短输入, 彩虹表需存储的表并不大, 计算资源消耗也不多, 因此效果较好.

#### 2 消息认证 / 签名

详见 [HMAC](消息认证码/HMAC.md), 将*哈希函数*与*共享密钥*结合, 既可以验证消息未被篡改 (完整性), 也可认证发送者身份 (真实性). 当然, 认证与签名更好的办法是使用 [数字签名](../公钥密码/数字签名.md)

#### 3 文件完整性校验

用于公开下载的文件或程序, 也会提供哈希值, 供用户验证完整性. 可以防止感染病毒或被恶意篡改.

在云盘软件上传大型文件时, 程序会先在数据库寻找相同杂凑值, 如果该杂凑值对应文件已在云端存在, 就直接关联而不是重新上传.

