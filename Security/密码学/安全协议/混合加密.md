## 混合加密

混合加密指综合运用 "[公钥加密](../公钥密码/公钥密码.md)和[对称加密](../分组密码/分组密码.md)" 的加密结构, 将公钥密码用于密钥协商, 对称加密用于高性能加密, 兼顾两者优点. 现代安全通信协议 (如 [SSH](../../../Network/ApplicationL5/SSH.md), [TLS/SSL](../../../Network/VPN/SSL.md)) 皆使用此类方式, 并结合了更多密码学工具. 以下是自己总结的一般步骤. 

混合加密主要分为以下两个步骤, 后附推荐的现代密码套件. 
- 基于公钥密码的密钥协商: ECDH-Curve25519-SHA2, ECDH-Nistp256-SHA2, DiffieHellman-SHA2
- 基于对称密码的附带消息认证的对称加密 (AEAD): AES-GCM-SHA2, ChaCha20-Poly1305-SHA2

### 双向认证密钥协商

| 步骤 | Alice                                                                 | 数据流向           | Bob                                                                    | 说明                                          |
|:----:| --------------------------------------------------------------------- | ------------------ | ---------------------------------------------------------------------- | --------------------------------------------- |
|  1   | $T_{1}=TimeStamp\Vert \mathrm{PRNG}(\dots)$                           | $T_{1}\to$         |                                                                        |                                               |
|  2   |                                                                       | $\leftarrow T_{2}$ | $T_{2}=TimeStamp\Vert \mathrm{PRNG}(\dots)$                            | 交换临时会话 ID. 保证新鲜性, ID 通常由用户标识, 随机数与时间戳派生                              |
|  3   | $K_{1}=\mathrm{PRNG}(\dots)$                                          |                    | $K_{2}=\mathrm{PRNG}(\dots)$                                           | 生成随机会话密钥                              |
|  4   | $S_{1}=\set{\mathrm{Hash}(K_{1}\Vert  T_{2})}_{SK(A)}$          |                    |                                                                        |                                               |
|  5   | $S_{2}=\set{K_{1},S_{1}}_{PK(B)}$                                     | $S_{2}\to$         | $K_{1},S_{1}=\set{ S_{2}}_{SK(B)}$                                     | 公钥加密保护签名和会话密钥                    |
|  6   |                                                                       |                    | $\mathrm{Hash}(K_{1}\Vert T_{2})\stackrel{?}{=}\set{ S_{1} }_{PK(A)}$  | 数字签名保护真实性, 哈希保护完整性            |
|  7   |                                                                       |                    | $S_{3}=\set{\mathrm{Hash}(K_{2}\Vert T_{1})}_{SK(B)}$                  |                                               |
|  8   | $K_{2},S_{3}=\set{ S_{4}}_{SK(B)}$                                    | $\leftarrow S_{4}$ | $S_{4}=\set{K_{2},S_{3}}_{PK(A)}$                                      |                                               |
|  9   | $\mathrm{Hash}(K_{2}\Vert T_{1})\stackrel{?}{=}\set{ S_{3} }_{PK(A)}$ |                    |                                                                        |                                               |
|  10  | $K=K_{1}\oplus K_{2}$                                                 |                    | $K=K_{1}\oplus K_{2}$                                                  | 双方临时密钥派生共享密钥                      |
|  11  | $S_{5}=\mathrm{PRF}_{K}(T_{1},T_{2},S_{1},S_{2},S_{3},S_{4},T_{3})$   | $S_{5}\rightarrow$ |                                                                        | (可选) 双方通过挑战, 确认共享密钥和上下文一致 |
|  12  |                                                                       | $\leftarrow S_{6}$ | $S_{6}=\mathrm{PRF}_{K}(T_{1},T_{2},S_{1},S_{2},S_{3},S_{4},f(T_{3}))$ | $f()$ 可以是简单线性函数, 如 $f(x)=x+1$, 仅用于证明 Bob 拥有共享密钥                                              |

协议结果:
- Alice 和 Bob 共享临时会话密钥 $K$. 
- Bob 和 Alice 进行了双向身份验证
	- 临时会话标识符 $T_{1},T_{2}$ 保证了新鲜性.
	- 双方皆参与密钥生成, 也保证了不是重放
	- ...$SK(A), SK(B)$ 签名保证了真实性...

伪随机函数 $PRF$ 一般选用 $\mathrm{HMAC}$,.... 

第 10 步中, 双方通过临时值派生共享秘密, 此过程有多种方式: 
- $K=K_{1}\oplus K_{2}$ 简单异或.
- [DiffieHellman 构造过程](../公钥密码/DiffieHellman.md), 即 $K_{1}$ 实际形如 $g^{X}$, 自身持有 $Y$, 组成秘密 $g^{XY}$.
- ${} K=\mathrm{KDF}(K_{1},K_{2})$ 各类密钥派生函数. 如 $\mathrm{Hash}(K_{1}\Vert K_{2})$.

<br>

以上是混合加密的认证密钥交换的一般形式, 以下是几种更简洁的实现方式, 参考了常见的[基于公钥的认证密钥交换技术](认证的密钥协商协议/基于公钥的认证密钥协商.md).

#### 基于 DH 的认证密钥协商

#### 基于 NSPK 的认证密钥协商

组合NSPK

### 加密信道

| 步骤 | Alice                                    | 数据流向         | Bob                                                    | 说明                       |
|:----:| ---------------------------------------- | ---------------- | ------------------------------------------------------ | -------------------------- |
|  12   | $C_{2}=\set{ M }_{K}$              |                  |                                                        |                            |
|  13  | $S_{2}=\mathrm{HMAC}_{K} (C_{2})$        | $C_{2},S_{2}\to$ | $C_{2}\stackrel{?}{=}\mathrm{HMAC}_{K}(C_{2})$         | 消息认证保护完整性         |
|  14  |                                          |                  | $M=\set{ C_{2} }^{-1}_{K}$                             | 对称加密保护数据           |

协议结果:
- 通过会话密钥 $K$ 保护通信双工信道的机密性.
- 通过会话密钥 $K$ 或其派生密钥 $k=\mathrm{KDF}{(K)}$ 保护通信双工信道的完整性.

注意计算 $\mathrm{HMAC}$ 时不能输入明文 $M$, 明确安全目标是检测 $C_{2}$ 是否在信道中被篡改. 最佳实践是**先加密后认证**的处理顺序 (Encrypt-then-MAC, EtM), 抵御[填充攻击 (CCA2)](../分组密码/填充.md); 直接检测密文是否被篡改, 无须解密的额外步骤, 也加快了验证速度. 数字签名则需要[先签名再加密](../公钥密码/RSA/RSA%20签名.md), TLS 使用 EtM 模式, PGP 使用先签名再加密消息, 都是正确的, 有微妙区别.

早期 TLSv1.2 版本中, 对称加密使用先 MAC 后加密的策略: $\set{ M\ \Vert\ \mathrm{HMAC}_{K}(M) }_{K}$. 但处于实践和安全性经验, TLSv1.3 改为使用类似上述的 AEAD 策略.

## 代理加密

代理加密 (Proxy Re-encryption, PRE) 指数据的持有者授权*代理*将加密数据从一个接收方转换为另一个接收方, **过程中代理不知晓原始明文.** 代理加密一般通过公钥密码实现, 数据持有者将同一明文给不同接收方重复加密的成本转嫁给代理, 同时数据不会泄露给代理. 

....