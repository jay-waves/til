### 为什么密钥长度应不小于分组长度?

香农信息论证明要实现**无条件安全**, 密钥长度至少与明文长度相同, 并且是完全随机和只使用一次的 (即 One-Time Pad). 证明[^2]主要有以下三点:
1. 对于任何密文 $c$, 任何明文 $m\in\mathcal{M}$ 出现的概率应该是相同的.
2. 密钥必须有随机性和唯一性, 对于同一密钥 $k$, 不能将不同明文 $m_{1}\neq m_{2}$ 加密为同一密文, 即 $Enc_{k}(m_{1})\neq Enc_{k}(m_{2})$.
3. 对于同一密文 $c$, 为了确保任意明文 $m\in\mathcal{M}$, 都等概率映射到 $c$ 上, 至少需要 $|\mathcal{M}|$ 种不同的密钥. 因此明文和密钥数量至少一样多, 即 $|\mathcal{K}|\geq|\mathcal{M}|$.

[^2]: 这里描述了[可证明安全](../可证明安全.md)中对完美加密的证明思路.

### 为什么要引入分组密码？

密码的作用是将一串字符串 $1^{n}$ 替换为另一串不相关字符串. 现代对称密码通常保证明文和密文的等长性, 主要有三点原因, 第一是避免因长度变化导致的额外信息泄露, 第二是避免引入额外填充步骤导致安全风险, 第三是长度一致性保证了加密对上层其他步骤是透明的, 避免一致性导致的处理复杂性. 

对于替换 $1^{n}\to 1^n$, 假设字符串基底为 $2$, 单个字符串的替换结果可能有 $2^{n}$ 种情况. 考虑一个密钥 $k$ 代表的映射 $Enc_{k}(\cdot)$, 总将明文空间 $|\mathcal{M}|=2^{n}$ 个明文, 一一映射到密文空间 $|\mathcal{C}|=2^{n}$ 个密文. 这种映射共有 $2^{n}!$ 个.

当长度 $n$ 较小时, 替换种类较少, 易被穷举攻击 (如针对凯撒密码的字母频率攻击). $n$ 较大时, 密钥存储成本会上升, 此时可以用密钥生成器对短密钥进行迭代和扩展, 然后将字符串作为一个整体加密, 类似流密码; 也可以将字符串拆分为中等长度的等长分组, 每个分组独立加密.

## 分组密码定义

分组密码 (block cipher): $E:\ \  1^{k}\times 1^{n}\to 1^{n}$

分组密码引入了**扩散和混淆**安全需求:

- 混淆 (confusion): 使密钥和明文之间的关系变得复杂, 通常和非线性变换相关.
- 扩散 (diffusion)[^3]: 使密文和明文之间关系变得复杂, 将明文的统计结构分散, 通常和线性变换相关. 扩散类似于**雪崩效应**.

[^3]: 关于混淆和扩散区别, 可参考 [Confusion and Diffusion in AES](https://crypto.stackexchange.com/questions/51219/confusion-and-diffusion-in-the-aes-functions)

为了实现良好的扩散和混淆效果, 分组密码多采用多轮迭代加密, 组件包括*多轮子密钥的派生算法, 多轮加密网络结构, 增强扩散和混淆效果的独立结构*, 经典加密结构有:
- [Feistel](Feistel-结构/Feistel.md)
- [SP Network](SP-结构/代换置换网络.md)


分组密码将长明文划分为等长分组进行加密, 每组独立使用加密算法. 在不同组之间引入迭代关系, 可以增强加密效果, 详见 [链接模式](链接模式.md).

分组密码的性能通常被认为快于[公钥密码](../公钥密码/ReadMe.md), 慢于[流密码](../流密码与伪随机数/ReadMe.md).

### 潜在攻击手段

攻击者通常只具有概率多项式时间计算能力, 称为 Probabilistic Polynomial Time, PPT 攻击者. 密码协议能抵抗 PPT 攻击者, 就称为**密码学安全的**; 如果额外考虑了有无限计算能力的攻击者, 就称为**信息论安全**的. [^1]

[^1]: 此部分的详细定义可见[可证明安全](../可证明安全.md)

针对密码协议的攻击, 从攻击者所掌握信息分类, 有:
1. 唯密文攻击: 只知道密文.
2. 已知明文 (KPA): 知道一些明密文对.
3. 选择明文 (CPA): 掌握 Enc(,k), 可以选择明文, 并得到其对应密文.
4. 选择密文 (CCA): 掌握 Dec(,k), 可以选择密文, 并得到对应明文.
5. 选择文本: 选择明文 + 选择密文