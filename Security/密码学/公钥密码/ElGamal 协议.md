基于离散对数困难问题, 可以用于加密和签名. 比较古早的基于离散对数的加密算法, 在椭圆曲线群上构造的 ElGamal 算法称为 [ECElGamal](ECC/ECElGamal.md); ElGamal 签名算法则衍生出 [Schnorr 协议](数字签名/Schnorr%20协议.md) 和 [DSA](数字签名/DSA%20协议.md) 等经典协议.

## ElGamal 加密

由于使用了随机数, 所以又称随机化加密. 使同一明文使用同一公钥加密产生的密文不同, 有效防御选择明文攻击和重放攻击等.

ElGamal 体制效率没有 RSA 高, 并且消息长度有两倍膨胀.

### 1 密钥生成

1. 选取大素数 $q$, 使求解离散对数问题在 $\mathbb{Z}_{q}$ 上困难
2. 选取 $\mathbb{Z}_{q}^*$ 上的本原元 $g$
3. 选随机整数 $X_{A}\in \left[1, q-2\right]$, 计算 $Y_{A}=g^{X_{A}}\pmod q$

则 Alice 的**公钥**为 $\{q, g, Y_{A}\}$, **私钥**为 $\{X_A\}$

### 2 加密

Bob 向 Alice发送消息 $M\in\left[1, q-1\right]$ :

1. 选取**一次性**随机数 ${} k\in \mathbb{Z}_{q-1} {}$
2. 计算一次性密钥 $K=(Y_{A})^{k}\pmod q$
3. ${} C_{1}=g^{k}\pmod q {}$
4. $C_{2}=KM\pmod q$

Bob 向 Alice 发送密文对 $\left(C_{1}, C_{2}\right)$

### 3 解密

Alice 恢复 $M=C_{2}(C_{1}^{X_{A}})^{-1}\pmod q$

**正确性证明**:

$K\equiv(Y_{A})^{k}\pmod q\equiv (g^{X_{A}})^k\pmod q$

使用 $C_1$ 恢复出 $K$:  
$C_{1}^{X_{A}}=(g^{k})^{X_{A}}\pmod q$

使用 $K$ 和 $C_{2}$恢复出 $M$:  
$C_{2}\equiv KM\pmod q\equiv (g^{X_{A}})^{k}M\pmod q$

### 4 安全性分析

公开信道上有: $C_{1}$, $C_{2}$, $\{q, g, Y_{A}\}$, 要恢复 $M$, 就要恢复 $K=g^{k\cdot X_{A}}$, 但是敌手没有 $X_{A}$, 只有 ${} g^{k}$ 和 ${} g^{X_{A}}$, 由离散对数问题困难性, 没办法恢复出 $K$. 

安全性由如下困难性保证:  

1. 知道 $C_{1}=g^{k}$ 和 $g$, 无法解出 $k$
2. 知道 $Y_{A}=g^{X_{A}}$ 和 $g$, 无法解出 $X_{A}$

$k$ 和 $X_{A}$ 任一泄露, 明文都会泄露. 所以两者都是密钥.   

不加随机值 $k$ 的DH体制无法实现加密功能, 因为只需求 $Y_{A}^{-1}$ 即可解出 $M$

#### 针对 ElGamal 加密的随机数重用攻击

对于使用同一随机数的一对密文 $C_{1,2}=KM_{1}$, $C_{2,2}=KM_{2}$, 构造: $$\frac{C_{1,2}}{C_{2,2}}=\frac{KM_{1}}{KM_{2}}=\frac{M_{1}}{M_{2}}$$. 若 $M_{1}$ 泄露, 所有使用该k加密的明文块皆泄露

因此 ElGamal 体制的随机数 $k$ 不能重复使用!

***

## Elgamal 签名

### 1 密钥生成

1. 选取大素数q, 使求解离散对数问题在 $\mathbb{Z}_{q}$ 上困难
2. 选取 $\mathbb{Z}_{q}^*$ 上的本原元 $g$
3. 选随机整数 $X\in \left[1, q-2\right]$, 计算 $Y=g^{X}\pmod q$

则 Alice 的**公钥**为 $\{q, g, Y\}$, **私钥**为 $\{X\}$

### 2 签名

1. ${} m=\mathrm{hash}(M) {}$, M为待签字消息
2. 选择随机数 $k$, 满足 $(k,p-1)=1$[^1]
3. $S_{1}=g^{k}\pmod p$
4. $S_{2}=k^{-1}(m-XS_{1})\pmod {p-1}$

最终签名为 $Sig(X, M)=\{S_{1},\ S_{2}\}$, 以及 $M$

[^1]: 这里 K 选取的复杂性, 也是后续 Schnorr 等算法使用 Zp 上子群的原因.

### 3 验证

1. $m=Hash(M)$, M为原始消息
1. $V_{1}=g^{m}\pmod p$
2. $V_{2}=Y^{S_{1}}S_{1}^{S_{2}}\pmod p$

3. 验证 $V_{1}\stackrel{?}{=} V_{2}$

**正确性证明**:
$$XS_{1}+kS_{2}=XS_{1}+kk^{-1}(m-XS_{1})=m \pmod{\phi(p)}$$
于是: $$V_{2}=Y^{S_{1}}S_{1}^{S_{2}}=g^{XS_{1}+kS_{2}}\pmod p=g^{m}\pmod p\equiv V_{1}$$


### 4 安全性分析

$k$ 作为临时密钥隐藏, 公开临时公钥 $S_{1}=g^{k}$

用私钥 $X$ 对明文 $m$ 签名: $X+m$, 再用临时私钥对该签名加密: $k^{-1}(X+m)$. 临时私钥保证 $X+m$ 不会被篡改, 同时提供了随机性.

#### 私钥绑定随机数

思考如下不安全构造: (不将 $X$ 与 $S_{1}$ 绑定)
1. $S_{1}=g^{k}\pmod p$
2. $S_{2}=k^{-1}(m-X)\pmod {p-1}$

敌手可在不知晓私钥 $X$ 的条件下, 伪造全新的对 $m$ 的签名:
1. ${} S_{1}'=S_{1}^{e}=g^{ke}\pmod{p}\neq S_{1} {}$
2. $S_{2}'=e^{-1}k^{-1}(m-X)\pmod{p-1}=(ke)^{-1}(m-X)\pmod{p-1}\neq S_{2}$

这违背了签名者必须明确知晓签名内容的原则.

#### 针对 ElGamal 签名的随机数重用攻击

攻击者伪造签名, 等价于破解私钥 $X$, 归约于离散对数困难问题.

$k$不能泄露, 且不能重复使用. 如果重复使用, 私钥 $x$将由下列方程算出:
$$\begin{align}
H(m_{1})=XS_{1}+kS_{1}\\
H(m_{2})=XS_{2}+kS_{2}
\end{align}$$
