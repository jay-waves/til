
## 1 RSA签名

签名用于认证，**防止信息被篡改**

![|600](../../../../attach/密码学_RSA签名.png)

1. A 生成密钥, 在公共频道公开公钥 $(e, N)$, 自己保留私钥 $d$
2. A 对消息 msg 加签, 以防篡改: $s \equiv m^{d}\; (mod\ N)$, 并将 ${} (s, m) {}$ 发送给 B
3. B 用公钥 $e$ 验签, 即检验 $s$ 验签结果是否和m一致 $m' \equiv s^{d}\; (mod\ N)$, 检查 $m'\equiv m$

签名中 $m$ 虽然公开, 但只有 A 有能力生成 $s$

### 带附录的签名方式

明密文长度太长, 为加快速度减少成本, 通常采用取[杂凑值](../../消息摘要/ReadMe.md)的方法.  
除此之外, 采用哈希值, 长度易控制, 并且有很好的抗碰撞性.

签名流程:
1. 计算原始明文的哈希值 $H$
2. 用私钥对哈希值 $H$ 加密, 生成数字签名
4. 发送者将数字签名附加到原始明文上, 发送

一般情况下, 带附录的签名长度更长. 对于 RSA 签名, 若消息长度小于 $\frac{len(n)}{2}$ `bits`, 使用带消息恢复的 RSA 签名; 否则使用带附录的 RSA 签名.

## 2 先签名再加密

为了同时实现保密性和认证性，需要同时采用双重公钥加解密：

$$A\longrightarrow E_{SK_{A}} \longrightarrow E_{PK_{B}}\longrightarrow D_{SK_{B}}\longrightarrow D_{PK_{A}} \longrightarrow B$$

其中 $PK_{B}$ 用于保密, $PK_{A}$ 用于认证.  

推荐使用**先签名, 再加密**方式[^1], 而不是先加密再签名. 原因如下:
- 只有接收者可以验证, 获得签名内容. 保护签名者身份.
- **签名和明文绑定**, 接收者可以明确签发者知晓明文内容, 防止攻击者篡改或替换签名内容.

[^1]: 注意 MAC 的规范正相反, 要求先加密再签名, 加快验证速度, 见 [安全协议/混合加密](Security/密码学/安全协议/混合加密.md)

### 中间人攻击

不对签名加密是危险的.

- Alice 发送: 加密消息 $C$ 和对 $C$ 的数字签名 $S_{A}$
- Miledy 截获 Alice 的信息, 替换为用自身私钥的签名, 转发给 Bob: 加密消息 $C$ + 签名 $S_{M}$
- Bob 收到: $C$ + $S_M$, 在证书中匹配身份, 误认消息来源是 Miledy. 即使 Miledy 并不知道消息明文.

结论是, 从机制上, 必须确保签发者清楚明文内容, 才能执行签名操作.

对于教科书式 RSA, **先加密**还是**先签名**都是相同的. 由于[乘法同态性](Security/密码学/公钥密码/RSA/RSA-攻击/RSA-选择密文攻击.md), 总有 $(m^{d_{A}})^{e_{B}}=(m^{e_{B}})^{d_{A}}$. 即使先签名后加密, 仍然防御不了中间人攻击, 敌手可以用A的公钥恢复出 $(m^{e_{B}})^{d_{A}\times e_{A}}\equiv m^{e_{B}}$, 从而假冒消息来源. 为了保证==知道明文才能签名==, 可以将消息 $m$ 和签名 $m^{d_{A}}$ "组合"起来, 一起加密: $E(m\ \Vert\ m^{d_{A}})$.

