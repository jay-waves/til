**CCA, Choice CipherText Attack, 选择密文攻击**是针对 **Plain-RSA, 教科书式 RSA** 的有效攻击手段, 利用了 RSA 模乘运算的乘法同态性质: $$m_{1}^{e}\times m_{2}^{e}=(m_{1}\times m_{2})^{e}$$

通过 [OAEP 填充](../PKCS1.md)等引入随机的填充方式后, 让同一明文对应不同密文, 使敌手不能通过密文猜测明文模式, 从而增加 CCA 安全性.

### 选择密文攻击流程

假设敌手有选择密文攻击能力, 密文 $C$ 和明文 $M$, 选取随机数 $r$. 

此时敌手已知 $(C, e, N, r)$

1. 让 A 解密 $r^eC$. 因为 $r^eC=r^eM^e$, 所以解密结果为 $rM$
2. 计算 $r^{-1}\pmod{n}$
3. 计算 $M=r^{-1}\times rM\pmod{n}$

### 防御选择密文攻击

简单地添加随机数也不能完全防御该攻击: 加密方选取随机数 $K$, 然后加密拼接值: $$(K\Vert M)^{e}=(K\times{2^{n}}+M)^{e}$$

二进制数直接拼接 (通过移位实现), 从十进制来看是乘以 $2^{n}$, 仍没有完全掩盖明文模式. 

攻击者选取随机数 $r$, 构造: $$r^{e}C=r^{e}(K\times 2^{n}+M)^{e}=(r\cdot K\times 2^{n}+r\cdot M)^{e}$$

攻击者声明随机数为 $r\cdot K$ (欺骗了谕示机, 但是仍符合解密流程), 让谕示机解密 $r^{e}C$, 得到[^1] $$(rK\times 2^{n}+rM)$$, 同乘 ${} r^{-1}\pmod N {}$, 结果的最低 $n$ 位仍然是明文 $M$.

目前我认为相对简单并安全的方案是: $$M'=(K\Vert Hash(K)\oplus M)$$

[^1]: 这里假设谕示机不对解密出的明文格式进行审查. 在 PKCS#1 v1.5 填充中, 也是直接在 $M$ 之前附加随机数 $K$. 但是它要求 $K$ 和 $M$ 之间有一字节空白字符, 并且还有一些其他格式要求, 这导致攻击者自行构造的密文, 解密时得到的明文不符合格式要求, 被直接丢弃, 安全性高一些. PKCS#1 v1.5 当然也并不安全, 格式要求不能完全消除上述缺陷, 也不能保证 $M$ 的完整性, Bleichenbacher 攻击就是利用了这一点.

### 签名篡改攻击

签名运算, 即私钥加密同样有乘法同态性质. 敌手利用这一点可任意篡改签名:
1. 敌手分别向签发者请求 $m_{1}$ 和 $m_{1}^{-1}m_{2}$ 的无害签名, 即 $m_{1}^{d},(m_{1}^{-1}m_{2})^{d}$
2. 敌手计算: $m_{1}^{d}\times (m_{1}^{-1}m_{2})^{d}=m_{2}^{d}$, 在不知道私钥 $d$ 的情况下, 完成了对 $m_{2}$ 的签名. $m_{2}$ 可能是有害签名, 如 "本机构自愿向xxx转账1000BTC". 

防御手段参考 [PKCS#1 PSS 填充算法](../PKCS1.md). 注意, 如果签名者仅对消息 $M$ 的哈希值 $Hash(M)$ 进行签名, 攻击者就难以伪造有意义的签名: $$(Hash(M))^{d}$$