## Computational Security

1. Security is only guaranteed against efficient adversaries that run for some feasible amount of time. 
2. Adversaries can potentially succeed (i.e., security can potentially fail) with some very small probability.

two approaches to define the above relaxations precisely:

### the Concrete Approach

*A scheme is $(t, \epsilon)-\mathsf{secure}$ if any adversary running for the time at most t succeeds in breaking the scheme with probability at most $\epsilon$.*

### the Asymptotic Approach

*A scheme is $\mathsf{secure}$ if any PPT (probablistic polynomial time) adversary succeeds in breaking the scheme with at most negligible probability.*

Given **security parameter n**, one can view n as corresponding to the length of the key. Also, we can view *running time of the adversary, as well as its success probability* as functions of n.
- PPT adversary: there is some polynomial $p$ such that the adversary runs for time at most $p(n)$ when the security parameter is n.
- negligible: probability smaller than any inverse polynomial in n. *iff for every polynomial p, there is a N such that for all $n>N$ it holds that $f(n)<\frac{1}{p(n)}$*. In other words, for all constants c, there is N such that for all $n>N$ it holds that $f(n)<n^{-c}$.

## EVA-Secure [^1]

**The adversarial indistinguishability experiment $\text{PrivK}^{eav}_{\mathcal{A}, \Pi}(n)$:**

1. The adversary $\mathcal{A}$ is given input $1^n$, and outputs a pair of messages $m_{0}, m_{1}$, with $\vert m_{0}\vert =\vert m_{1}\vert$
2. A key k is generated by running $\textbf{Gen}(1^{n})$, and an uniform bit $b\in \{0, 1\}$ is chosen. Ciphertext $c\leftarrow \textbf{Enc}_{k}(m_{b})$ is computed and given to $\mathcal{A}$. We refer to c as the **challenge ciphertext**.
3. $\mathcal{A}$ outputs a bit b'.
4. $\mathsf{PrivK}^{eav}_{\mathcal{A}, \Pi}(n)=1$ if $b'=b$, and 0 otherwise.

$$\begin{align}
&Pr[\mathsf{PrivK}^{eav}_{\mathcal{A}, \Pi}(n)=1] \\
&=\frac{1}{2}\cdot Pr[\mathcal{A}(m_{0 })=0]+\frac{1}{2}\cdot Pr[\mathcal{A}(m_{1})=1] \\
&=\frac{1}{2} - \frac{1}{2}\cdot P[\mathcal{A} (m_{0 })=1]+\frac{1}{2}\cdot Pr[\mathcal{A}(m_{1})=1]
\end{align}$$

![|450](../../../../attach/Pasted%20image%2020231229112635.png)

#### Definition 3.8
A private-key encryption scheme $\Pi = (Gen, Enc, Dec)$ has **indistinguishable** encryptions in the presence of as eavesdropper, or is **EAV-secure**, if for all probablistic polynomial-time (PPT) adversaries $\mathcal{A}$ there is a negligaible funciton **negl** such that, for all n(security parameter), $$Pr[PrivK^{eav}_{\mathcal{A}, \Pi}(n)=1]\leq \frac{1}{2}+negl(n)$$

#### Definition 3.14

G is a deterministic polynomial-time algorithm such that for any n and any input $s\in \{0,1\}^{n}$, the result $G(s)$ is a string of length $\ell(n)$. G is a **pseudorandom generator** if the following coditions hold:
1. **Expansion:** For every n it holds that $\ell(n)> n$
2. **Pseudorandomness:** For any PPT alogorigthm D, there is a negligible funciton $\mathsf{negl}$, such that: $$\vert Pr[D(G(s))=1]-Pr[D(r)=1]\vert\leq \mathsf{negl}(n)$$, where the first probability is taken over uniform choice of $s\in\{0,1\}^{n}$ and the randomness of D, and the second probability is taken over uniform choice of $r\in\{0, 1\}^{\ell(n)}$ and the randomness of D.

call $\ell(n)$ the expansion factor of G.

#### Construction 3.17 EVA-Secure Scheme

fixed-length private-key encryption scheme for messages of length $\ell(n)$ as:
- $\mathsf{Gen}$: input $1^{n}$, choose uniform $k\in{0, 1}^{n}$ as key.
- $\mathsf{Enc}$: input $k$, $m\in{0, 1}^{\ell(n)}$, output: $c:=G(k)\oplus m$
- $\mathsf{Dec}$: $m:=G(k)\oplus c$

### Multi Messages Encryption

**Multiple-message evesdropping experiment $\mathsf{PrivK}^{mult}_{\mathcal{A}, \Pi}(n)$**:
1. $\mathcal{A}$ is given input $1^{n}$, outputs **equal-length list** of messages: $\vec{M_{o}}=(m_{0,1},\dots,m_{0,t})$, $\vec{M_{1}}=(m_{1,1},\dots,m_{1,t})$, with $\vert m_{o,i}\vert=\vert m_{1,i}\vert$ for all i.
2. $k\leftarrow \mathsf{G}(1^{n})$, uniform bit $b\in{0, 1}$. For all i, $c_{i}\leftarrow \mathsf{Enc}_{k}(m_{b,i})$, $\vec{C}=(c_{1},\dots,c_{t})$ is given to $\mathcal{A}$
3. $\mathcal{A}$ outputs b'. 
4. Experiment outputs 1 if b'=b, 0 otherwise.

$\mathsf{Enc}$ also let $m_{b,i}, m_{b,j}$ with $m_{b,i}=m_{b,j}$ become different $c_{b,i}\neq c_{b,j}$. Besides, it also hide same msgs in different msgs list (i.e. $0^n$ in $\vec{M}_{0}$, also $0^n$ in $\vec{M}_{1}$) 

#### Definition 3.18

scheme $\Pi=(\mathsf{Gen,Enc, Dec})$ has **indistinguishable multiple encryptions in presence of eavesdroppers**, if for all PPT $\mathcal{A}$, there is a *negligible* function $\mathsf{negl}$ such that $$Pr[\mathsf{PrivK}^{mult}_{\mathcal{A}, \Pi}(n)=1]\leq \frac{1}{2}+\mathsf{negl}(n)$$

## CPA & CCA security

see [CPA-Secure](CPA-Secure.md) and [CCA-Secure](CCA-Secure.md)

## Authenticated Encryption

AE (authenticated encryption) is an encryption scheme that achieves both:
- secrecy: CCA-security
- integrity: unforgeability

**The unforgeable encryption experiment** $\text{Enc-Forge}_A(n)$:
1. A key $k$ is generated by running $\text{Gen}(1^n)$.
2. The adversary $A$ is given $1^n$ and access to an encryption oracle $\text{Enc}_k(\cdot)$. The adversary eventually outputs a ciphertext $c$. Let $m := \text{Dec}_k(c)$ and let $Q$ denote the set of all queries that $A$ submitted to its oracle.
3. $A$ succeeds if and only if (1) $m \neq \bot$ and (2) $m \notin Q$. In that case the output of the experiment is defined to be 1. ($\bot$ denoting failure)

![|450](../../../../attach/Pasted%20image%2020231229101908.png)

*A private-key encryption scheme $\Pi$ is unforgeable if for all [PPT](Private-Key%20Encryption.md) adversaries $A$, there is a negligible function $\text{negl}$ such that:
$$ \Pr[\text{Enc-Forge}_A(n) = 1] \leq \text{negl}(n). $$*

**Unforgeable + CCA-secure --> AE scheme**

### Authenticate-then-encrypt

Let $\Pi = (\text{Enc}, \text{Dec})$ be a private-key encryption scheme and let $\Pi_{M} = (\text{Mac}, \text{Vrfy})$ be a message authentication code, where in each case key generation is done by simply choosing a uniform n-bit key. Define a private-key encryption scheme $\Pi_{E}=(\text{Gen}', \text{Enc}', \text{Dec}')$ as follows:
- $\text{Gen}'$: on input $1^n$, choose independent, uniform $k_E, k_M \in \{0, 1\}^n$ and output the key $(k_E, k_M)$.
- $\text{Enc}'$: on input a key $(k_E, k_M)$ and a plaintext message $m$, compute $c \leftarrow \text{Enc}_{k_E}(m)$ and $t \leftarrow \text{Mac}_{k_M}(c)$. Output the ciphertext $(c, t)$.
- $\text{Dec}'$: on input a key $(k_E, k_M)$ and a ciphertext $(c, t)$, first check if $\text{Vrfy}_{k_M}(c, t) \stackrel{?}{=} 1$. If yes, output $\text{Dec}_{k_E}(c)$; if no, output $\bot$.

*Let $\Pi_{E}$ be a CPA-secure private-key encryption scheme, and let $\Pi_{M}$ be a strongly secure message authentication code. Then the above construction is an authenticated encryption scheme.*

[^1]: P60, *Introduction to Modern Cryptography* by Jonathan Katz