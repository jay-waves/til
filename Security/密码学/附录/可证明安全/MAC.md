## MAC[^1] 

A message authentication code (or MAC) consists of three probabilistic polynomial-time algorithms ($\mathsf{Gen, Mac, Vrfy}$) such that:

- The key-generation algorithm $\mathsf{Gen}$ takes as input the security parameter $1^n$ and outputs a key $k$ with $|k| \geq n$.
- $t \leftarrow Mac_k(m)$. The tag-generation algorithm Mac takes as input a key $k$ and a message $m \in \{0,1\}^*$, and outputs a tag $t$.
- $b := Vrfy_k(m,t)$. The deterministic verification algorithm $\mathsf{Vrfy}$ takes as input a key $k$, a message $m$, and a tag $t$. It outputs a bit $b$, with $b = 1$ meaning valid and $b = 0$ meaning invalid. (The Canonical way to perform verification is to simply recomput the tag t, and check for equalilty)

It is required that for every $n$, every key $k$ output by $Gen(1^n)$, and every $m \in \{0,1\}^*$, it holds that $Vrfy_k(m, Mac_k(m)) = 1$.

If there is a function $\ell$ such that for every $k$ output by $Gen(1^n)$, algorithm $Mac_k$ is only defined for messages $m \in \{0,1\}^{\ell(n)}$, then we call the scheme a fixed-length MAC for messages of length $\ell(n)$.

### Security

For a message authentication code $\Pi = (\text{Gen}, \text{Mac}, \text{Vrfy})$, an adversary $A$, and security parameter $n$:

**The message authentication experiment** $\text{Mac-forge}_{A, \Pi}(n)$:
- A key $k$ is generated by running $\text{Gen}(1^n)$.
- The adversary $\mathcal{A}$ is given input $1^n$ and oracle access to $\text{Mac}_k(\cdot)$. $\mathcal{A}$ eventually outputs $(m, t)$. Let $\mathcal{Q}$ denote the set of all queries that $A$ submitted to its oracle.
- $\mathcal{A}$ succeeds if and only if (1) $\mathsf{Vrfy}_k(m, t) = 1$ and (2) $m \not\in \mathcal{Q}$. In that case the output of the experiment is defined to be 1.

A MAC is secure if no efficient adversary can succeed in the above experiment with non-negligible probability: $$Pr[\mathsf{Mac-forge}_{\mathcal{A},\prod}(n)=1]\leq \mathsf{negl}(n)$$

*the above experiment has a small loophole: adversary can generate a new, valid tag t for previous  authenticated message $m_{i}\in\mathcal{Q}$, but $\mathsf{Mac-forge}$ still takes it secure.*


### Hash-MAC

### CBC-MAC[^2]

Let $F$ be a pseudorandom function, and fix a length funciton $\ell(n)>0$ (set $\ell(n)=\ell$). The basic CBC-MAC construnction is as follows:
- $\mathsf{Mac}$: on input a key $k\in \{0,1\}^{n}$ and a message $m$ of length $\ell(n)\cdot n$, do the following:
	1. Parse m as $m=m_{1},\dots,m_{\ell}$ where each $m_{i}$ is of length n.
	2. Set $t_{0}:= 0^{n}$. Then, for $i=1$ to $\ell$, set $t_{i}:=F_{k}(t_{i-1}\oplus m_{i})$.
- $\mathsf{Vrfy}$: on input a key $k\in\{0,1\}^{n}$, a message m, and a tag t, do: If $m$ is not of length $\ell(n)\cdot n$ then output 0. Otherwise, output 1 iff $t\stackrel{?}{=}\mathsf{Mac}_{k}(m)$

> see [CBC链接模式](../../分组密码/链接模式.md) for details

[^1]: P109-110, *Introduction to Modern Cryptography* by Jonathan Katz
[^2]: P121