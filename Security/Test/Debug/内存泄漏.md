## 内存释放的三种方式
-   *垃圾回收机制：GC*，在程序运行时不断寻找不再使用的内存，典型代表：Java、Go、Python
-   *手动管理内存的分配和释放*, 在程序中，通过函数调用的方式来申请和释放内存，典型代表：C++
-   *通过所有权来管理内存*，编译器在**编译**时会根据一系列规则进行检查， 典型代表：Rust。

#### 内存访问
访问数组数据结构时常见错误。
- 定义macros

```c
#define LEAST -1
#define  MAX
```
- 防止访问[-1]
	问题常见于栈等常见数据结构, 或倒序循环数组
	快速排查:
	
```c
if (i == -1)//i is the cursor visiting the array
	printf("error with -1");//you can add more info
```

#### 作用域错误

错误使用内存作用域，导致内存泄露。
e.g.
```c
int* foo() {
    int a;          // 变量a的作用域开始
    a = 100;
    char *c = "xyz";   // 变量c的作用域开始
    return &a;
}                   // 变量a和c的作用域结束
```
这段代码有两个严重问题：
1. a指向的内存在函数结束时就会被释放掉，返回的指针其实是悬空的。
2. c在常量区域新增了内存，但是函数结束后不会再被使用，这部分空间实际上浪费掉了。