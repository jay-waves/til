背景知识详见 [字符编码](../../../操作系统/sss/字符编码.md).

## c++20 utf-8 support

C++20 支持 utf-8, 但后续不计划支持其他编码 (及编码转换能力). 核心原因是, UTF-8 是支持 ASCII 的, 因此众多 IO 场景都可直接迁移.

c++20 引入 `u8string`, 内部的字节类型为 `char8_t`. 

```cpp
std::string s = u8"你好"; // 要求源码是 utf-8 编码的

std::fs::create_directories(u8"这是一个目录")
```

## character literals

单引号标注*字符字面量 (character literal)*, 双引号标注*字符串字面量 (string literal)*. 

```cpp
char c = 'A'; // 实际等价于一个整数常量

int x = 'AB';
int y = '你'; // 多字符字面量, 使用 int 来存储, 将编码拼接在同一个 int 中, 超过 4 字符就是未定义行为.
// 这种方式并不可靠, 其实际编码方式取决于源码文件的字符编码.

const char *s = "A"; // 字符串字面量, s 指向 {'A', '\0'}
```

其他字符串类型:
- `u8"AAAAA"` UTF-8 字符串, 等价于 `const char8_t*`
- `u"AAAAAA"` UTF-16 字符串, 等价于 `const char16_t*`
- `U""` UTF-32 字符串, 等价于 `const char32_t[]`
- `L""` 宽字符串, `const wchar_t[]`

## 第三方库

鉴于 C++ 不计划提供完整 Unicode 及编码支持, 第三方方法包括:
- ICU: 工业级 Unicode 标准库
- Boost.Text 
- libiconv, 或 POSIX `iconv()`

### 命令行工具

`iconv` 更改[字符编码](操作系统/sss/字符编码.md)方式. 

```sh
# 转换为 Windows 默认的 UTF-16LE 编码 
iconv -f utf-8 -t utf-16le data.txt

iconv -f GBK -t UTF-8 input.txt -o output.txt
```

`uconv` 则支持一些高级 Unicode 功能, 在 ICU 工具包中.