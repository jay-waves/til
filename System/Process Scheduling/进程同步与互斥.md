**进程同步**, 指并发导致程序异步性, 但多个进程存在逻辑上顺序, 需要调整其工作次序.

**进程互斥**, 指临界资源需要互斥访问. 须遵循以下原则:
- 空闲让进
- 忙则等待
- 有限等待: 有限时间能进入临界区, 防止饥饿.
- 让权等待: 进入不了临界区的进程, 需要释放 CPU, 防止忙等.

## 原子操作

高级语言的某一操作, 可能被编译为多条 CPU 指令. 在多线程环境下, 若执行该操作的指令时进程被其他线程抢占, 就可能导致该操作不一致. 因此系统提供**原子操作 (Atomic)**, 保证操作时不会被抢占. 

举一个例子 [^1], 线程一执行 `i=1; ++i;`, 线程二执行 `--i;`, 自增自减操作需要借用寄存器 `X`, 多线程下可能得到错误结果 `i=2` 或 `i=0`:

| 执行时间 | 指令 | 变量值   | 线程号 |
| -------- | ---- | -------- | ------ |
| 1        | i=1  | i=1      | 1      |
| 2        | X1=i | i=1,X1=1 | 1      |
| 3        | X2=i | i=1,X2=1 | 2      |
| 4        | X1++ | i=1,X1=2 | 1      |
| 5        | X2-- | i=1,X2=0 | 2      |
| 6        | i=X1 | i=2,X1=2 | 1      |
| 7        | i=X2 | i=0,X2=0 | 2       |



[^1]: 程序员的自我修养--编译, 装载与库. 俞甲子等. P25

## 信号量

信号量 (Semaphore) 是最简单的一种锁 (Lock).

### 信号量原理

**记录型信号量, binray semaphore**, 一次仅允许一个进程访问共享资源.

```c
wait(S) {
	while (S <= 0); // busy wait
	S--;
}

signal(S){
	S++;
}
```

**整数型信号量, counting semaphore**. 

```c
typedef struct {
	int              value;  // count of resouces
	struct process  *L;      // blocking queue
} semaphore;

wait(semaphore *S) {
	S->value--;
	if (S->value < 0) {
		block(S->L); // interrupt and sleep
	}
}

signal(semaphore *S) {
	S->value++;
	if (S->value <= 0) {
		wakeup(S->L);
	}
}
```

### 实现进程互斥

用 S 实现对临界资源的互斥访问, 此时信号量也称为**互斥量**. P (等待, proberen) 和 V (信号, verhogen) 操作必须成对出现, 信号量初值设为资源数.

```c
semaphore mutex = n;
P(&mutex); 

CriticalSection(); 

V(&mutex);
```

### 实现进程同步

保证代码执行顺序, 前 V 后 P, 信号量初始为 0. 对于复杂拓扑关系, 需要为每个前驱关系都设置一个同步信号量. 复用同步或互斥信号量时, 需要将同步 P 放在互斥 P 前, 防止达成 "占有并等待" 的死锁条件.

```c
semaphore S = 0; // make sure that c1 happens before c2

P1 {
	C1;
	V(S);
}

P2 {
	P(S);
	C2;
}
```

|                             | 信号量               | 互斥量     | 临界区           |
| --------------------------- | -------------------- | ---------- | ---------------- |
| 英文名                      | Semaphore            | Mutex      | Critical Section |
| 声明后, 能否被其他进程获取. (访问权) | 能                   | 能         | 否               |
| 获取后, 能否被其他进程释放. (所有权) | 能                   | 否         | 否               |
| 用途                        | 进程同步 | 保护单进程临界区, 直至其执行退出 | 指多个进程共享的代码区     | 

## 自旋锁

使用非自旋锁, 当前进程等待资源时, 会主动释放 CPU, 进入睡眠状态. 满足"让权等待"原则, 提高并发效率. 但对于较小较底层的临界区, 切换任务上下文的开销较大; 同时, 让出 CPU 等于让出缓存和 TLB, 当再次获取 CPU 时, 可能缓存已被污染, 需要重新缺页中断和读缓存.

```c
	wait(S) {
		while (S <= 0)
			sleep(0.1); // actively release CPU.
		S--;
	}
```

相反, 等待**自旋锁 (Spin Lock)** 时, 线程会持续**轮询**, 而不释放 CPU 资源. 

## 读写锁

读写锁 (Read-Write Lock) 思想是, 多线程同时*读数据*是线程安全的, 而*写数据*是不安全的, 若临界数据经常被读取而较少写入时, 使用普通锁是低效的. 

| state of rw_lock | shared access | exclusive access |
| ---------------- | ------- | --------- |
| free             | succeed | succeed   |
| shared           | succeed | wait      |
| exclusive        | wait    | wait          |

## 条件变量

条件变量 (Condition Variable) 也是种同步手段, 令多线程等待某一事件. 
1. 多个线程等待一个条件变量.
2. 某线程唤醒该条件变量
3. **所有**等待该条件变量的线程都会被唤醒.

## 可重入

可重入函数 (reentrant) 指函数尚未执行完时, 又一次进入该函数执行 (如多线程调用, 或递归调用). 函数可重入需要有以下几个特点:
- 不使用任何静态或全局的非常量变量
- 不返回任何静态或全局的非常量变量
- 仅依赖于调用方提供的参数
- 不依赖于单个资源的锁
- 不调用任何不可重入的函数

## 指令屏障

CPU 可能动态地调整指令顺序, 导致并发错误 [^1]. 下面程序 `p_inst = new T` 包含了三个步骤:
1. 分配内存
2. 调用构造函数
3. 将内存地址赋值给 `p_inst`

CPU 可能动态地将 2, 3 步顺序调换, 在单线程下是正确的. 但是在多线程下, 出现另一个对 `get_instance()` 的调用, 获取到了尚未构造完成的 `p_inst`, 造成可能的异常访问.

```c
volatile T* p_inst = 0;
T* get_instance()
{
	if (p_inst == NULL) {
		lock();
		if (p_inst == NULL)
			p_inst = new T;
		unlock();
	}
	return p_inst;
}
```

此时需要使用 CPU 提供 `barrier` 指令, 明确使 CPU 不要换序执行. (现代 CPU 大多采用乱序执行技术)

```c
	lock();
	if (p_inst == NULL) {
		T *temp = new T;
		barrier();
		p_inst = temp;
	}
	unlock();
```

编译器优化时, 也可能调整指令顺序. 类似地, 可使用 `volatile` 关键词:
1. 阻止编译器为优化速度, 将变量缓存至寄存器而不写回.
2. 阻止编译器调整标注 `volatile` 变量的指令顺序.

## 死锁

死锁 (deadlock) 指多个进程循环等待对方占有的资源, 其主要成因有==竞争系统资源, 进程推进不当==. 

| 名称   | 进程数量     | 进程状态       | 成因                 |
| ------ | ------------ | -------------- | -------------------- |
| 死锁   | 至少两个进程 | 阻塞态         | OS分配资源策略不合理 |
| 饥饿   | 可能为一     | 阻塞态, 就绪态 | OS分配资源策略不合理 |
| 死循环 | 可能为一     | 运行态         | 代码逻辑错误                     |

死锁的**必要条件**为: (必须同时成立)
- 互斥
- 占有并等待
- 非抢占
- 循环等待

### 死锁的处理策略

- 预防死锁, 使死锁必要条件至少其一不成立
- 避免死锁
- 已死锁, 死锁检测
- 忽略死锁 (linux, windows 大多采用)

#### 1 预防死锁

- 打破互斥
- 静态资源分配, *使进程申请资源时不占有其他资源*. 如, 一次性申请所有资源, 或没有(占有)资源时才能申请.
- 抢占已有资源. 如, 未申请成功进程释放其所有资源, 或允许部分资源被抢占.
- 为所有资源预先编号, 并规定封锁排序, 所有事务按顺序申请封锁.

#### 2 避免死锁

通过以后如何申请资源的额外信息, 决定是否分配资源. 最简单的策略是, ==进程声明每种资源可能用的最大数量, 据其动态检查资源分配情况, 以确保循环等待条件不成立==

如果分配资源的进程序列存在一个**安全序列**, 则系统处于**安全状态**. 安全序列定义为, 对进程序列 $<P_1, P_2, \cdots, P_n>$, 每个 $P_i$ 仍可申请的资源数不超过当前可用资源加上所有前序序列 $P_j$ 所持有的资源. 如果 $P_i$ 无法马上获得资源, 那么它等待所有前序 $P_j$ 结束返回资源.

非安全状态不一定是死锁, 但安全状态不会死锁: 
![|200](../../attach/Pasted%20image%2020230620175908.png)
