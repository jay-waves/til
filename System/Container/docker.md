## 核心概念

### 容器 Container

容器是镜像的运行实例, 可以被动态地启动/停止/移动/删除, 容器删除后数据也会丢失, 所以一般将host的某个卷挂载到容器. 

容器类似虚拟机, 和host隔离, 有自己的文件系统/网络配置/进程空间.

### 镜像 Image

轻量可执行的独立软件包, 包括*代码, 运行时, 库, 环境变量和配置文件*. 

镜像内容由多个层次构成 (每层代表dockerfile一个指令), docker利用层次结构来重用层次, 以加速部署和节省空间. 镜像一旦构建完, 就不可变; 构建构成中, docker 会逐层构建, 每个层基于已构建层次, 在独立临时容器中构建, 并为已构建的层次生成缓存, 方便出错时快速重新构建. 修改 dockerfile 后, 修改应只影响当前层和之后的层, 不影响之前的层. 镜像实际就是多个层的组合, 所以多个镜像也可以类似的组合在一起.

如大型项目, 将各个构建部分拆分后, 构建为多个 docker images, 然后仅设计这些 images 间的依赖关系即可. 举例而言, navigation2 image 基于 ros2 image, ros2 image 基于 ubuntu image. docker 不仅构建时能够重用镜像, 运行时也可以直接连接多个docker.

清理镜像:
- `docker image prune`
- `docker system prune`

#### Docker 实现机制

**层次构建**: Docker 构建时, 如果某一层需要修改前一层的文件, 该文件会被复制到当前层 (写时复制, copy-on-write, CoW), 当前层存在一个 OverlayFS 来记录这些改动, 保证修改不会影响到前一层, 这也意味着除非重新构建否则无法删除之前层的缓存. 而容器运行时有 UnioinFS 来将分层文件系统组合为统一文件系统, 让FS对容器内进程透明和连续. 镜像层次和命令层次是类似的, 也可以复用.

**容器分离**: 前一层次一旦被构建好, 就不可被更改, 除非重新构建. 镜像被放入容器内运行时, docker会在素有只读层上添加一个可写层, 所有(持久)写入操作都发生在这个容器层上, 而镜像是只读的. 基于此, Docker 的各个容器彼此隔离, 有独立的运行环境/文件系统/网络配置/进程空间, 允许为同一镜像创建多个容器实例. 由于共享了同样的镜像层, 节省了磁盘空间

**轻量级并发**: 容器们共享宿主机操作系统内核, 并且可以共享镜像层. 所以启动时间较快, 并且磁盘空间也占用较小.

***

## 管理镜像

拉取 DockerHub 镜像: `docker pull <name>:<tag>`

删除镜像:
1. 先删除基于该镜像的容器
2. 再删除镜像
