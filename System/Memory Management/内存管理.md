---
url: https://tldp.org/LDP/tlk/mm/memory.html
---

内存管理应提供如下功能:

- 内存空间的分配和回收
- 内存空间的扩充: 覆盖技术, 交换技术, 虚拟内存技术.
- 地址转换
	- 编译时转换, 适用于单道程序系统
	- 装入时转换, 静态重定位. 一次装入全部内存空间, 此后无法改变, 多用户难以共享.
	- 运行时转换, 动态重定位. 特定硬件对地址映射支持, 可分配到不连续内存空间, 运行时再进行地址转换.
- 存储保护: 检查地址: $base \leq addr \lt base+limit$

## 内存分配

- 外碎片: 内存中空闲分区太小, 而难以利用
- 内碎片: 分配给进程的内存区域, 进程实际未使用

连续内存分配方法产生的内存碎片多, 而离散内存分配方法(索引或链表)则效率相对较低. 

现有技术是使用 **[虚拟内存技术](虚拟内存.md)**, 每个进程独占整个连续逻辑内存空间, 由 MMU 负责分配离散分配物理内存空间, 并将逻辑地址**转化**为物理地址.

举例而言, 4GB 主存的机器跑多道程序. 如果使用虚拟内存, 那么每个程序进程都可以独占 4GB 大小的逻辑地址空间.

### 分页内存管理

将物理内存分为等长块, 称为**页框 Frame**, 逻辑内存也分为同样长的块, 称为**页面 Page**, 每个页面独立编号 PFN (Page Frame Number). 以页框为单位为进程分配内存, 不会产生外碎片 (有内碎片), 32 位机器页宽为 `4KB`, 64 位为 `8KB`.

操作系统维护**空闲页框表**, 负责管理物理内存空闲页框. 维护**页表 (PT)**, 记录页面与页框的映射关系, 页表项被称为 PTE.

```c
// page table entry
struct 
```

![|100](../../attach/Pasted%20image%2020230620195945.png)

假设逻辑空间大小为 $2^m$ 字节, 页大小为 $2^n$ 字节. 则可以通过截取地址, 来区分页面号和业内偏移: `page_offset = addr & (2^n-1); page_number = addr >> n`

![|300](../../attach/Pasted%20image%2020230620200145.png)

分页的地址转化过程: 

![|500](../../attach/Pasted%20image%2020230620200358.png)

注意, 若页表在内存中, 则过程需要两次访存. 有两个重要寄存器:
- 页表基址寄存器 (PTBR) 存储页表的内存位置
- 页表限长寄存器 (PRLR), 检查页面号是否越界

引入块表 (转化表缓冲区, TLB), 保存在 CPU 高速[缓存](缓存.md)中, 查找速度更快:

![|400](../../attach/Pasted%20image%2020230620201111.png)

为评价TLB效率, 引入**有效访问时间 EAT**:

$\text{EAT}=\lambda(a+b)+(1-\lambda)(a+2b)$. 其中查找TLB时间为a, 内存存取时间为b, 命中率为 $\lambda$.

### 分级页表

32 位系统对于每个进程都要存 4MB 页表, 占用大量**连续**内存, 大部分页表项是无用的. 因此照搬虚拟内存页表的思路, 衍生出多级页表. linux 使用三级页表.

![|450](../../attach/Pasted%20image%2020240507170816.png)