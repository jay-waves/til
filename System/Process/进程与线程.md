## 进程

**进程的定义:** 一个程序在一个数据集上的一次执行.  
注意区分程序和进程, 程序是**静态**存储在磁盘上的可执行文件, 进程是**动态**保存在内存中的程序的一次执行过程.

### 内存中结构

进程资源:
- 代码段, Text, 存放指令序列
- 数据段, Data, 全局变量和静态变量
- 堆栈段, 栈一般又编译器自动分配, 堆则由程序员动态分配.

![|150](../../attach/Pasted%20image%2020230619171849.avif)

进程控制块, PCB, Process Control Block:

操作系统用于存储进程相关信息的数据结构, 存放在独立内存区域. 

![|150](../../attach/操作系统_进程内存布局.avif)

### 进程的创建, 终止, 唤醒, 切换, 阻塞

1. `ps` 查看进程
2. `pstree` 查看进程树. linux 初始进程是 init

`fork()` 系统调用, 调用一次, 返回两次. 用于创建父进程的完整副本. 返回值用于区分父子进程, 父进程返回新建子进程id, 子进程返回0, 出错返回-1.

`clone()`调用, 创建轻量级**线程**, 有选择地继承父进程资源.

![|500](../../attach/Pasted%20image%2020230619181858.avif)

`exec()` 系统调用, 将进程**完全**替换为新程序的进程.

`exit()`系统调用, 中止进程. 

`wait()`, `waitpid()`系统调用, 父进程等待子进程执行结束, 并获取其返回值.

![|300](../../attach/Pasted%20image%2020230619182508.avif)

进程唤醒指将进程**从阻塞态变为就绪态**, 切换则指**就绪态和运行态的转换.** [操作系统并发](中断与异常.md)需要**进程上下文切换 (Context Switch):**

![|400](../../attach/Pasted%20image%2020230619183343.avif)

## 线程

随着 [CPU 单核频率](../../HardWare/计算机组成/高速缓存.md)接近上限 (<8GHz), 多核心并行执行越发重要, 多线程是多核并行执行的方法之一. 线程是 CPU 调度基本单元, 拥有独立的"线程 ID, 线程状态, 程序计数器 PC, 寄存器组, 栈空间", 多线程可隶属于同一进程. 线程控制块称为 TCB (thread control block).

进程是资源分配的基本单位, 内核级线程则是 CPU 调度的基本单位:

|                            | threads of the same process | process     | examples                                      |
| -------------------------- | --------------------------- | ----------- | --------------------------------------------- |
| address                    | shared                      | independent |                                               |
| heap                       | shared                      | independent | malloced array                                |
| stack, registers           | independent                 | independent | function parameters, local variables, PC, esp |
| runtime                    | shared                      | independent | my_program.exe                                |
| data, bss, mmap            | shared                      | independent | static/global variables, opened files,        |
| TLS (thread local storage) | independent                 | independent |                                               |
| os resources               | shared                      | independent | file handlers, socket handlers                                              |

![|400](../../attach/操作系统_线程和进程的资源对应关系.avif)

#### 多线程优势

- 耗时任务或轮询时, 单线程陷入等待状态. 多线程可高效利用等待时间, 例如等待大量网络响应.
- 线程资源比进程轻量, 所以其创建与上下文切换更经济. 
- 同一进程下的线程数据共享比进程间数据交换更方便.

#### 多线程实现模型

多对一模型: 指用户线程, 线程在用户空间管理, 内核只支持进程. 线程切换无需内核参与, 但线程无法并发, 单线程阻塞会导致整体阻塞. 多对一线程也被称为**协程**, 见 [Go/并发](../../Language/Go/Go%20并发.md)

![|150](../../attach/Pasted%20image%2020230619203728.avif)

一对一模型: 并发性好, 但内核模式切换开销较大, 线程总数量受到内核限制. 系统 API 创建的线程一般为一对一线程, 如 linux 下的 `clone()`, windows 下的 `CreateThread()`.

![|150](../../attach/Pasted%20image%2020230619203732.avif)

多对多模型: 这里用户线程指"代码逻辑", 而内核线程则指"运行机会"

![|150](../../attach/Pasted%20image%2020230619203736.avif)

## 协程

线程是操作系统调度的单位, 进程是操作系统资源分配的单位. 也就是说, 线程是*抢占式 (preemptive)*的, 其时间片调度交由操作系统负责. 由于发生调度的时机不可预料, 线程间如果存在共享资源, 需要用[同步原语](进程同步与互斥.md)避免数据竞争或死锁. 

为什么线程和进程需要抢占? 因为操作系统要运行多个应用程序, 如果某个异常程序在抢占资源但空耗不让出控制权 (不管是恶意的, 还是愚蠢的), 会导致操作系统对其他任务的响应变差或阻塞. 时间片抢占式调度, 是为了让操作系统更有效率地实现多个任务并发和共享资源, 不让某一个异常任务导致系统整体的资源利用率下降.

这个操作系统资源可以是 CPU 资源, 也可以是硬盘和网卡资源. 要让多进程和多线程提高程序性能, 不仅可以利用 CPU 多个核心的并发执行, 也可以利用 网络 / 硬盘 / GPU / 外设 的资源并发. 一个应用程序, 如果想用多进程加速, 需要利用操作系统提供的各类[进程间通信](../IPC%20&%20Network/linux%20进程间通信.md)接口来实现进程内信息的共享和同步; 如果想用多线程加速, 则可以直接共享同一父进程内的资源, 但是仍需要同步机制 (一般是编程语言或操作系统提供的各类同步原语) 来安全地共享信息. 哪怕是单核 CPU, 多线程也会导致意想不到的执行绪紊乱. 并且, 同步和线程上下文切换带来的损耗不算小, 都需要切换到内核态.

*协程 (Coroutine)*, 是一种**协作式** (而非抢占) 的用户态线程的概念, 它明确定义了单线程下多个任务之间执行权的交接点. 同一线程下的协程是无法在 CPU 上并行的, 执行权的切换只会发生在编程人员明确地放弃执行权之后. 换言之, 线程并发需要编程人员用同步原语隐式约束程序的发生序关系, 而协程则要求编程人员明确定义各个事件的发生序关系. 这样省去了同步和上下文切换的开销, 也更安全.

协程通常需要一个*事件循环 (event loop)* 追踪所有挂起的协程任务, 这些协程任务可能在等待某个 文件 / 网络 事件的完成 (挂起), 完成后通过底层的 IO 多路复用机制通知事件循环, 事件循环会执行该协程对应的回调函数 (恢复). 协程在等待外部事件时, 会主动让出控制权, 使事件循环不阻塞. **挂起和恢复**有很多种实现方式:
- aysnc/await: `async` 定义异步函数, `await` 挂起协程. 
- Go 语言, 协程在 `<-chan` 时挂起, 数据到达时恢复. `go` 也是用户态线程, 但是仍是抢占调度, 由 Go 运行时管理.

> 参考: https://zhuanlan.zhihu.com/p/147608872
