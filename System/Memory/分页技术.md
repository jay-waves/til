---
source: https://tldp.org/LDP/tlk/mm/memory.html
---

## 分页技术

- 外碎片: 内存中空闲分区太小, 而难以利用
- 内碎片: 分配给进程的内存区域, 进程实际未使用

连续内存分配方法产生的内存碎片多, 而离散内存分配方法则效率相对较低. 现代操作系统采用分页技术 (paging) 来解决外碎片问题. 后来, 为了解决物理内存空间不足的问题, 分页技术逐渐和[虚拟内存](虚拟内存.md)结合.

### 分页内存管理

将物理内存分为等长块, 称为**页框 (Page Frame)**, 逻辑内存也分为同样长的块, 称为**页面 Page**, 每个页面独立编号 PFN (Page Frame Number). 以页框为单位为进程分配内存, 不会产生外碎片 (有内碎片), 32 位机器页宽为 `4KB`, 64 位为 `8KB`.

操作系统维护**空闲页框表**, 负责管理物理内存空闲页框. 维护**页表 (PT)**, 记录页面与页框的映射关系, 页表项被称为 PTE.[^1] 

[^1]: PTE 内容详见 [虚拟内存](虚拟内存.md).

![|100](../../attach/Pasted%20image%2020230620195945.avif)

假设逻辑空间大小为 $2^m$ 字节, 页大小为 $2^n$ 字节. 则可以通过截取地址, 来区分页面号和业内偏移: 

```
       m-n             n
+---------------+---------------+
|  page number  |  page offset  |
+---------------+---------------+

page_offset = addr & (2^n -1);
page_number = addr >> n;
```

分页的地址转化过程如下图所示. **注意, 虚拟地址和物理地址的转换, 由硬件 MMU (Memory Management Unit) 完成, 页表维护则由操作系统完成**.

![|500](../../attach/操作系统_虚拟地址转换.avif)

注意, 若页表在内存中, 则过程需要两次访存. 有两个重要寄存器:
- 页表基址寄存器 (PTBR) 存储页表的内存位置
- 页表限长寄存器 (PRLR), 检查页面号是否越界

引入块表 (转化表缓冲区, Translation Looaside Buffer, TLB), 位置在 CPU [高速缓存](../../HardWare/计算机组成/高速缓存.md)中, 保存最近使用的地址映射, 从而加速地址转换:

![|400](../../attach/操作系统_引入TLB的虚拟地址转换.avif)

为评价TLB效率, 引入**有效访问时间 EAT**:

$\text{EAT}=\lambda(a+b)+(1-\lambda)(a+2b)$. 其中查找 TLB 时间为 $a$, 内存存取时间为 $b$, 命中率为 $\lambda$.

### 分级页表

32 位系统对于每个进程都要存 4MB 页表, 占用大量**连续**内存, 大部分页表项是无用的. 因此照搬虚拟内存页表的思路, 衍生出多级页表.

![|450](../../attach/Pasted%20image%2020240507170816.avif)

 linux-x64 使用四级页表:
 - PGD (Page Global Directory) 页全局目录
 - PUD (Page Upper Directory) 页上级目录
 - PMD (Page Middle Directory) 页中间目录
 - PTE (Page Table Entry) 页表条目
