直接为进程分配物理内存的缺点如下:
1. 地址空间不隔离, 程序地址是全局可见的, 容易招致恶意程序攻击.
2. 内存使用效率低, 空间不够时, 需要将整个程序换入换出.
3. 程序运行地址不确定. 导致程序编写 (数据与指令跳转) 复杂.

引入虚拟内存地址技术, 即每个进程的虚拟地址空间都是隔离的完整的 (32 位下为 4GB), 由操作系统的 MMU (Memory Management Unit) 负责将虚拟地址转化为物理地址. 技术上, 装入时, 程序部分装入; 运行时, 数据换入换出, 按需调页; 当物理内存不足时, 不需要的换出.

```
CPU -- vaddr --> MMU -- paddr --> Memory
```

## 虚拟页式存储

 虚拟内存技术很自然地和[分页技术](分页技术.md)结合, 扩展出如下功能:
- 按需调页, Demand Paging
- 页面置换, Swapping: 将暂时不使用的页面换出内存
- 页框分配: 为各个进程分配页框数量
- 访问控制, Access Control.

### 按需调页

为页表增加: 有效无效位, 其中无效位有*相关页无效, 页面有效但不在内存中*两种情况. 当试图访问无效页表项时, 会产生**缺页中断, Page Fault Trap**.

![|450](../../attach/Pasted%20image%2020230621083243.avif)

为了支持按需调页, 通常在外存划分**交换区**, 交换区文件连续分配, 以支持更快读写. 其他区域称为文件区, 离散分配, 利用率高.

### 页面置换

按需调页选中的外存页调入内存时, 若内存无空闲页框, 则按**页面淘汰算法**换出一个页, 然后调入选中页. 为了减少交换负担, 还用*脏位 dirty bit* 记录页面是否被修改, 若未被修改, 则直接丢弃.

![|400](../../attach/Pasted%20image%2020230621091127.avif)

常见页面交换算法:
- FIFO
- OPT, 最优
- LRU, 最近最少使用 (linux 使用)
- CLOCK, 时钟置换算法, 二次机会

### 页框分配

**抖动, 颠簸, thrashing**: 一个进程页面的频繁换入换出. 产生抖动的诱因是驻留集过小, 即驻留集远小于局部 (程序最近访问页面集合). 解决办法也就是使驻留集约等于局部, 当物理内存严重不足时, 虚拟内存提供的扩存作用有限.

> 内存空间扩充的技术: 覆盖 (已淘汰), 交换, 虚拟内存

### 访问控制

MMU 除了完成地址转换和缓存, 还根据页表条目 (PTE) 中的权限位来控制检查访问权限.
比如:
- 防止程序访问脏数据.
- 防止可执行程序内存段被写入.
- 防止可写入内存段被执行.

```c
// page table entry
typedef struct {
	uint64_t present    : 1; // 是否在内存中
	uint64_t rw         : 1; // 0 只读, 1 可读写
	uint64_t us         : 1; // 0 标识内核态可访问, 1 标识用户态也可以访问.
	uint64_t pwt        : 1; // 页级写透缓存策略
	uint64_t pcd        : 1; // 页级缓存禁用, 1 标识禁用缓存
	uint64_t accessed:  : 1; // 1 标识被访问过
	uint64_t dirty      : 1; // 1 标识页已被写过 
	uint64_t pat        : 1; // 页属性表
	uint64_t global     : 1; // 全局位, 1 标识全局页, 不刷新 TLB
	uint64_t availabel  : 3; // 保留给操作系统软件使用
	uint64_t pfn        : 40; // **物理页框号**, 12-51 位
	uint64_t reserved   : 11; // 保留, 置 0 填充
	uint64_t nx         : 1; // 1 页面不可执行
} pte_t[];
```

操作系统通过下列掩码检查和设置对应权限:

| 标志位宏          |                                                        |
| ------------- | ------------------------------------------------------ |
| `V`           | 此 PTE 有效                                            |
| `FOE`         | Fault on Execute, 尝试执行该页面时, 处理器将执行缺页中断 |
| `FOW`         | Fault on Write, 尝试写入该页面时, 处理器将执行缺页中断   |
| `FOR`         | Fault on Read, 尝试读取该页面时, 处理器将执行缺页中断                                          |
| `KRE`, `KWE`  | 内核态程序可以读/写该页面.                             |
| `URE`, `UWE`  | 用户态程序可以读/写该页面.                             |
| `_PAGE_DIRTY` |                                                        |
| `_PAGE_ACCESSED`              |                                                        |
