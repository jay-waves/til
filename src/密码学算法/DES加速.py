"""
优化分析：
本身拿int实现，见[DES.py](DES.py.md)，不是拿str实现，速度天然优势。但还有很多优化空间。

什么耗时间？permutate置换操作

有没有不必要的耗时？key重复产生

优化方向：
1. 减少S盒深度，由三阶变二阶。并尝试和前后E盒、P盒合并，尤其是E盒，完全没必要存在。
2. 轮密钥复用，缓存常用数据
3. python数据结构：列表 -> 元组，优化python特性（减少使用python特性）
4. 简化置换操作步骤，位操作，置换掩码
5. 减少调用（这个影响不突出）

学到的知识：
1. profile函数分析
2. 分析时间消耗，比如计算操作和循环次数，比较不同操作区别
3. 学会了缓存与函数修饰器

尽管优化了如此多步骤，最终还是TLE（超出时间）。Python优化无数，不如拿C重写一遍，真的是这样。
"""

## permutate置换函数迭代
'''原版本
小端存储（低位在纸面左）也是系统瓶颈，每次访问都需要减法访问相对位置
要想优化，其实可以修改置换表'''
def permutate(table, data, data_size):
    result = 0
    size = len(table)
    for dest, src in enumerate(table):
        result |= ((data>>(data_size-src))&1) << (size -dest -1)
    return result


'''v1.0版本
我将**列表反序**存储了, 可以减少两个减法，下面是优化后的置换函数
我挺喜欢这个版本的，很简洁
'''
Pbox = [25, 4, 11, 22, 6, 30, 13, 19, 9, 3, 27, 32, 14, 24, 8, 2, 10, 31, 18, 5, 26, 23, 15, 1, 17, 28, 12, 29, 21, 20, 7, 16]
def permutate(table, data, data_size):
    result = 0
    for dest, src in enumerate(table):
        result |= ((data>>(data_size-src))&1) << (dest)
    return result


'''v2.0'''
def gen_permutate_mask(permutation_table: list[int], data_size) -> list[int]:
    masks = [0] * data_size # table可能小于源码位数
    for dest_pos, src_pos in enumerate(permutation_table):
        masks[data_size - src_pos] |= (1 << (dest_pos))
    return tuple(masks)

def bitmask_permutate(n: int, masks: list[int]) -> int:
    result = 0
    for i, mask in enumerate(masks):
        if n & (1 << i):
            result |= mask
    return result

# 使用字典缓存16轮密钥
```python
rk_cache = {}

def rk_gen(k0):
    '''
    16轮密钥生成
    '''
    if not rk_cache.get(k0):
        k = _PC1(k0)
        LK = k >> 28
        RK = k & 0xFFF_FFFF
        K = [0 for _ in range(16)]
        for i in range(16):
            LK, RK, K[i] = round(LK, RK, i)
        rk_cache[k0] = K
    else:
        K = rk_cache[k0]
    return K

# 使用cache装饰器缓存16轮密钥
from functools import cache

@cache
def rk_gen(k0):
    '''
    16轮密钥生成
    '''
	k = _PC1(k0)
	LK = k >> 28
	RK = k & 0xFFF_FFFF
	K = [0 for _ in range(16)]
	for i in range(16):
		LK, RK, K[i] = round(LK, RK, i)
    return K

# 手搓cache装饰器, 可以帮助理解python装饰器如何工作:
def cache_decorator(funct):
	cache = {}

	def wrapper(*args, **kwargs):
		# 将所有参数转化为一个可以用作字典键的元组
		key = (*args, *kwargs.items())

		if key not in cache:
			# 如果参数没有缓存过, 计算并存储结果
			cache[key] = func(*args, **kwargs)
			
		return cache[key]

@cache
def rk_gen(k0):
    '''
    16轮密钥生成
    '''
	k = _PC1(k0)
	LK = k >> 28
	RK = k & 0xFFF_FFFF
	K = [0 for _ in range(16)]
	for i in range(16):
		LK, RK, K[i] = round(LK, RK, i)
    return K

"""
Python语法的一些**F&Q**
1. cache字典作为一个局部变量, 为什么能在函数结束后一直存在?

Python的确会在函数执行结束后, 使用GC回收局部变量. 但如果存在**闭包**结构时, 被引用的局部变量不会被销毁.  
**闭包**指的是子函数调用了外部函数的变量, 这导致了外部函数变量被绑定到内部函数, 即使外部函数已经被执行结束, 该被引用变量仍不会被销毁. 在这个例子中, wrapper实际上是被rk_gen变量引用了,  所以其生命周期会跟随rk_gen延长.
`@cache`只是python的一种语法糖, 其真正语法时 `rk_gen = cache(rk_gen)`, 装饰器本质上是`funct(old_funct) -> new_funct`的一类**函数**.

2. `*args`和`**kwargs`有什么区别?

`*args`用来收集位置参数, `*` 用来将传入的位置参数*元组*解包  
`**kwargs`用来收集关键字参数, `**` 用来将传入的关键字*字典*解包  

两者同时使用时, `funct(*args, **kwargs)`可以收集传入一个函数的所有参数. 事实上, python也就是这么干的, 传入参数时会先将所有位置参数打包成一个元组, 所有关键字参数打包成一个字典传入函数, 函数再解包. 一般情况下, 实际使用了python的元组赋值来解包, 如对函数`function(a, b, c)`实际是`a, b, c <- *args`

3. `key in cache` 是什么操作? 字典不是使用`cache.get(key)`来访问键嘛?

可以这么用, 这会检查key是否在字典cache的**键**中, 返回布尔值. `get()方法`遇到key不存在, 则会返回`None`

"""

"""
装饰器可以在不修改函数本体的情况下, 为函数添加更多功能. 比如可以用来**构造测试, 用来统计执行时间和日志**等
函数profile分析

```python
import cProfile
profiler = cProfile.Profile()

profiler.enable()
my_function()
profiler.disable()

profiler.print_stats()
```
**可以多次开关，结果会汇总到print_stats里**  
结果中参数：
- totime: 不含子调用消耗时间
- cumtime: 含子调用总消耗时间
"""

# key.py 轮密钥生成模块
```python
def permutate(n: int, masks: list[int]) -> int:
    result = 0
    for i, mask in enumerate(masks):
        if n & (1 << i):
            result |= mask
    return result


_rot_schedule = (1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1)
_rot = lambda x, i: ((x<<i) & 0xfffffff) | (x>>(28-i))
_PC2 = lambda LK, RK: permutate( (LK<<28)|RK , key_PC_2)
_PC1 = lambda k: permutate(k, key_PC_2)

def round(LK_28b, RK_28b, cnt):
    '''
    单轮子密钥生成
    '''
    i = _rot_schedule[cnt]
    LK_28b = _rot(LK_28b, i)
    RK_28b = _rot(RK_28b, i)
    return LK_28b, RK_28b, _PC2(LK_28b, RK_28b)

# 最终没用cache库，因为有的环境不适配
rk_cache = {}
def rk_gen(k0):
    '''
    16轮密钥生成
    '''
    if not rk_cache.get(k0):
        k = _PC1(k0)
        LK = k >> 28
        RK = k & 0xFFF_FFFF
        K = [0 for _ in range(16)]
        for i in range(16):
            LK, RK, K[i] = round(LK, RK, i)
        rk_cache[k0] = K
    else:
        K = rk_cache[k0]
    return K

# 主函数 main.py
import key

def permutate(n: int, masks: list[int]) -> int:
    result = 0
    for i, mask in enumerate(masks):
        if n & (1 << i):
            result |= mask
    return result

# e 和 Sbox进行合并, e两边扩展的位就是S盒的行
def ES(data_32b, rk):
    # 原E盒
    data_34b = ((data_32b&1)<<33) | (data_32b << 1) | (data_32b>>31)
    data_6b = [0]*8
    for i in range(8):
        data_6b[7-i] = (data_34b & 0x3f) ^ (rk & 0x3f)
        data_34b = data_34b >> 4
        rk = rk>>6

    # 原S盒
    data_32b = 0
    for i in range(8):
        data_32b = (data_32b << 4) | Sbox[i][data_6b[i]]
    return data_32b

def DES(k, data, op) -> int:
	# 生成16轮轮密钥
    K = key.rk_gen(k)

    #初始化数据
    data0 = permutate(data, IP)
    L = data0 >> 32
    R = data0 & 0xFFFF_FFFF

    for cnt in range(16):
        i = cnt if op else (15-cnt)
        L, R = R, L^ permutate(ES(R, K[i]), Pbox)

    data_64b = (R << 32) | L
    return permutate(data_64b, IP_inv)

if __name__ == '__main__':
    T = int(input())
    data = int(input(), 16)
    k0 = int(input(), 16)
    op = int(input())
    for _ in range(T):
        data = DES(k0, data, op)
    print('0x{:016x}'.format(data))


# 替换盒数据
# 这个真的是核心科技，不外传。

Sbox = (
    (14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1, 3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8, 4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7, 15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13), 
    (15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14, 9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5, 0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2, 5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9), 
    (10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10, 1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1, 13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7, 11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12), 
    (7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3, 1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9, 10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8, 15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14), 
    (2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1, 8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6, 4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13, 15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3), 
    (12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5, 0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8, 9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10, 7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13), 
    (4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10, 3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6, 1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7, 10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12), 
    (13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4, 10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2, 7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13, 0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11)
    )

# bit mask for permutate
Pbox = (2048, 131072, 32, 134217728, 33554432, 1024, 1048576, 1, 
		8192, 2097152, 8, 268435456, 536870912, 128, 262144, 16777216, 
		2147483648, 4194304, 4096, 64, 67108864, 4, 65536, 256, 
		16384, 1073741824, 16, 524288, 2, 512, 32768, 8388608)

IP = (549755813888, 128, 140737488355328, 32768, 36028797018963968, 8388608, 9223372036854775808, 2147483648,
	  274877906944, 64, 70368744177664, 16384, 18014398509481984, 4194304, 4611686018427387904, 1073741824, 
	  137438953472, 32, 35184372088832, 8192, 9007199254740992, 2097152, 2305843009213693952, 536870912, 
	  68719476736, 16, 17592186044416, 4096, 4503599627370496, 1048576, 1152921504606846976, 268435456, 34359738368,
	  8, 8796093022208, 2048, 2251799813685248, 524288, 576460752303423488, 134217728, 17179869184, 
	  4, 4398046511104, 1024, 1125899906842624, 262144, 288230376151711744, 67108864, 8589934592, 
	  2, 2199023255552, 512, 562949953421312, 131072, 144115188075855872, 33554432, 4294967296, 
	  1, 1099511627776, 256, 281474976710656, 65536, 72057594037927936, 16777216)

IP_inv = (144115188075855872, 562949953421312, 2199023255552, 8589934592, 33554432, 131072, 512, 2, 
		 576460752303423488, 2251799813685248, 8796093022208, 34359738368, 134217728, 524288, 2048, 8,
		 2305843009213693952, 9007199254740992, 35184372088832, 137438953472, 536870912, 2097152, 8192, 32,
		 9223372036854775808, 36028797018963968, 140737488355328, 549755813888, 2147483648, 8388608, 32768, 128, 
		 72057594037927936, 281474976710656, 1099511627776, 4294967296, 16777216, 65536, 256, 1, 
		 288230376151711744, 1125899906842624, 4398046511104, 17179869184, 67108864, 262144, 1024, 4, 
		 1152921504606846976, 4503599627370496, 17592186044416, 68719476736, 268435456, 1048576, 4096, 16, 
		 4611686018427387904, 18014398509481984, 70368744177664, 274877906944, 1073741824, 4194304, 16384, 64)

key_PC_1 = (0, 134217728, 524288, 2048, 2147483648, 549755813888, 140737488355328, 36028797018963968, 
			0, 67108864, 262144, 1024, 1073741824, 274877906944, 70368744177664, 18014398509481984, 
			0, 33554432, 131072, 512, 536870912, 137438953472, 35184372088832, 9007199254740992, 
			0, 16777216, 65536, 256, 268435456, 68719476736, 17592186044416, 4503599627370496, 
			0, 8388608, 32768, 128, 8, 34359738368, 8796093022208, 2251799813685248, 
			0, 4194304, 16384, 64, 4, 17179869184, 4398046511104, 1125899906842624,
			0, 2097152, 8192, 32, 2, 8589934592, 2199023255552, 562949953421312, 
			0, 1048576, 4096, 16, 1, 4294967296, 1099511627776, 281474976710656)
			
key_PC_2 = (256, 262144, 0, 64, 4194304, 32768, 8, 1024, 
			4096, 524288, 32, 16384, 2048, 0, 16, 8388608, 
			65536, 512, 0, 1048576, 4, 0, 128, 8192, 
			1, 2097152, 131072, 2, 1099511627776, 134217728, 2147483648, 0, 
			17592186044416, 34359738368,0, 137438953472, 67108864, 17179869184, 0, 70368744177664, 
			536870912, 549755813888, 140737488355328, 33554432, 8589934592, 35184372088832, 68719476736, 0, 
			1073741824, 268435456, 274877906944, 4398046511104, 4294967296, 2199023255552, 16777216, 8796093022208)
