汉明码 (Hamming) 是一种错误检纠正码, 可以**修正1位错误**.

## 原理:   

在2的幂次位插入冗余位 (实际是奇偶校验位) , 并把数据位按其二进制编码与冗余码相关联. 某一位出错时, 就会引起相关校验位的变化. 不仅能发现错误, 还是找出错误位置. 校验位位数应使用 $2^r\geq k+r+1$ 确定, 其中r是冗余位位数, k是数据二进制位数.

### 构造过程

| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 |
| ------- | ------- | ------- | ------- | ------- | ------- | ------- | ------- | ------- | -------- | -------- |
| $h_1$   | $h2$    | $d_1$   | $h_3$   | $d_2$   | $d_3$   | $d_4$   | $h_4$   | $d_5$   | $d_6$    | $d_7$    |
| `0001`  | `0010`  | `0011`  | `0100`  | `0101`  | `0110`  | `0111`  | `1000`  | `1001`  | `1010`   | `1011`         |

## 汉明距离

### 什么是汉明距离

下面引用自维基百科：

> 在信息论中，两个等长字符串之间的汉明距离（英语：Hamming distance）是两个字符串对应位置的不同字符的个数。换句话说，它就是将一个字符串变换成另外一个字符串所需要替换的字符个数。

对于两个数字来说，汉明距离就是转成二进制后，对应的位置值不相同的个数。例如，假设有两个十进制数`a=93`和`b=73`，如果将这两个数用二进制表示的话，有`a=1011101`、`b=1001001`，可以看出，二者的从右往左数的第3位、第5位不同（从1开始数），因此，`a`和`b`的汉明距离是`2`。

汉明距离是以**理查德·卫斯里·汉明**的名字命名的。在通信传输过程中，累计定长二进制字中发生翻转的错误数据位，所以它也被称为信号距离。汉明距离在包括信息论、编码理论、密码学等领域都有应用。

### 如何计算汉明距离

既然目标是计算两个二进制数的对应位的值不同的个数，我们自然会联想到**异或**运算。因为**异或**运算的原则就是**相同为0，不同为1**。因此，通过计算`c = a XOR b`，然后统计`c`中的各二进制位出现的`1`的次数，就能得到汉明距离了。

为了统计`c`的二进制格式中`1`出现的次数，我们可以将`c`逐步右移，并且每次将其和`1`（假设位宽是8，也就是`00000001`）进行**与运算**，以检测最右边的位是否为`1`（如果最右边的位是`1`，那么与运算的结果肯定也是`1`，否则为`0`）。一个循环下来，就能检测出`c`中`1`出现的次数了。

```
def hammingDistance(x, y):
    xor = x ^ y
    distance = 0
    # 每次右移，最左边都会补零，因此截止条件是xor已经是一个零值了
    while xor:
        if xor & 1:
            distance = distance + 1
        xor = xor >> 1
    return distance
```

### 布赖恩·克尼根算法

上述算法是一个很符合直觉的算法，但需要遍历所有的位。这里给出一个更精巧的思路，可以提高性能。

我们先观察如下一个现象：对于任意一个非零的二进制数`a`（将其看作无符号数），考虑`a`和`a-1`的关系。由于`a`非零，那么`a`中总有一些位为`1`。假设`a`中最低位的`1`处于从右向左数的第`N`位。那么，`a`的第`N`位以及第`N`位以后的每一位的值和`a-1`的第`N`位及第`N`位以后的每一位的值均不同。

举个例子就很容易理解了。我们以8位数来描述。假设`a=10010000`，根据上述描述，从右往左数的第一个`1`出现在第`5`位，那么有`N=5`。同时可以计算出`a-1=10001111`，可以看到，从第`N`位开始，`a`的后缀是`10000`，而`a-1`的后缀是`01111`。满足上述描述的现象。

进一步地，我们可以发现，如果对`a`和`a-1`进行与操作，就会直接消去位于最后一位，也就是第`N`位的`1`。还以上面的`a`为例，`a & (a-1)=10000000`。可以看到，我们不需要遍历，而是通过一次运算，就可以把`a`中的最后一个`1`消掉。如果我们一直重复这项操作，那么`a`里有多少个`1`，我们就仅需要多少次`a & (a-1)`的操作，就能把`a`化为`0`了。而这个操作的次数正是我们所要求的。

再举例看一下这个过程。假设一个数`x=10010001`，那么有：

```
x = 10010001, x-1 = 10010000, y = x & (x - 1) = 10010000
y = 10010000, y-1 = 10001111, z = y & (y - 1) = 10000000
z = 10000000, z-1 = 01111111, z & (z - 1) = 00000000
```

`x`里有`3`个`1`，经过上述过程，只需要`3`次操作，就能得知`x`中有多少个`1`。而如果使用遍历的方法的话，需要`8`次操作才行。

改进的求汉明距离的代码如下：

```
def hammingDistance(x, y):
    xor = x ^ y
    distance = 0
    while xor:
        distance = distance + 1
        xor = xor & (xor - 1)
    return distance
```

