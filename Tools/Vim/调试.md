# 调试

## 常规建议

如果你遇到了奇怪的行为，尝试用这个命令重现它：

    vim -u NONE -N

这样会在不引用 vimrc（默认设置）的情况下重启 vim，并且在 **nocompatible** 模式下（使用 vim 默认设置而不是 vi 的）。（搜索 `:h --noplugin` 命令了解更多启动加载方式）

如果仍旧能够出现该错误，那么这极有可能是 vim 本身的 bug，请给 [vim_dev]("https://groups.google.com/forum/#!forum/vim_dev") 发送邮件反馈错误，多数情况下问题不会立刻解决，你还需要进一步研究

许多插件经常会提供新的（默认的/自动的）操作。如果在保存的时候发生了，那么请用 `:verb au BufWritePost` 命令检查潜在的问题

如果你在使用一个插件管理工具，将插件行注释调，再进行调试。

问题还没有解决？如果不是插件的问题，那么肯定是你的自定义的设置的问题，可能是你的 options 或 autocmd 等等。

到了一行行代码检查的时候了，不断地排除缩小检查范围知道你找出错误，根据二分法的原理你不会花费太多时间的。

在实践过程中，可能就是这样，把 `:finish` 放在你的 **vimrc** 文件中间，Vim 会跳过它之后的设置。如果问题还在，那么问题就出在`:finish`之前的设置中，再把`:finish`放到前一部分设置的中间位置。否则问题就出现在它后面的半部分设置，那么就把`:finish`放到后半部分的中间位置。不断的重复即可找到。

## 调整日志等级

Vim 现在正在使用的另一个比较有用的方法是增加 debug 信息输出详细等级。现在 Vim 支持 9 个等级，可以用`:h 'verbose'`命令查看。

```vim
:e /tmp/foo
:set verbose=2
:w
:set verbose=0
```

这可以显示出所有引用的文件、没有变化的文件或者各种各样的作用于保存的插件。

如果你只是想用简单的命令来提高等级，也是用 `:verbose` ，放在其他命令之前，通过计数来指明等级，默认是 1.

```vim
:verb set verbose
"  verbose=1
:10verb set verbose
"  verbose=10
```

通常用等级 1 来显示上次从哪里设置的选项

```vim
:verb set ai?
"      Last set from ~/.vim/vimrc
```

一般等级越高输出信息月详细。但是不要害怕，亦可以把输出导入到文件中：

```vim
:set verbosefile=/tmp/foo | 15verbose echo "foo" | vsplit /tmp/foo
```

你可以一开始的时候就打开 verbosity，用 `-V` 选项，它默认设置调试等级为 10。 例如：`vim -V5`

## 查看启动日志

## 查看运行时日志

## Vim 脚本调试

如果你以前使用过命令行调试器的话，对于`:debug`命令你很快就会感到熟悉。

只需要在任何其他命令之前加上`:debug`就会让你进入调试模式。也就是，被调试的 Vim 脚本会在第一行停止运行，同时该行会被显示出来。

想了解可用的 6 个调试命令，可以查阅`:h >cont`和阅读下面内容。需要指出的是，类似 gdb 和其他相似调试器，调试命令可以使用它们的简短形式：`c`、 `q`、`n`、`s`、 `i`和 `f`。

除了上面的之外，你还可以自由地使用任何 Vim 的命令。比如，`:echo myvar`，该命令会在当前的脚本代码位置和上下文上被执行。

只需要简单使用`:debug 1`，你就获得了[REPL](https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop)调试特性。

当然，调试模式下是可以定义断点的，不然的话每一行都去单步调试就会十分痛苦。（断点之所以被叫做断点，是因为运行到它们的时候，运行就会停止下来。因此，你可以利用断点跳过自己不感兴趣的代码区域）。请查阅`:h :breakadd`、 `:h :breakdel`和 `:h :breaklist`获取更多细节。

假设你需要知道你每次在保存一个文件的时候有哪些代码在运行：

```vim
:au BufWritePost
" signify  BufWritePost
"     *         call sy#start()
:breakadd func *start
:w
" Breakpoint in "sy#start" line 1
" Entering Debug mode.  Type "cont" to continue.
" function sy#start
" line 1: if g:signify_locked
>s
" function sy#start
" line 3: endif
>
" function sy#start
" line 5: let sy_path = resolve(expand('%:p'))
>q
:breakdel *
```

正如你所见，使用`<cr>`命令会重复之前的调试命令，也就是在该例子中的`s`命令。

`:debug`命令可以和[verbose](#verbosity)选项一起使用。

### 运行时检测

需要的特性：+profile

Vim 提供了一个内置的运行时检查功能，能够找出运行慢的代码。

`:profile` 命令后面跟着子命令来确定要查看什么。

如果你想查看所有的：

```Vim
:profile start /tmp/profile.log
:profile file *
:profile func *
<do something in Vim>
<quit Vim>
```

Vim 不断地在内存中检查信息，只在退出的时候输出出来。（Neovim 已经解决了这个问题用 `:profile dump` 命令）

看一下 `/tmp/profile.log` 文件，检查时运行的所有代码都会被显示出来，包括每一行代码运行的频率和时间。

大多数代码都是用户不熟悉的插件代码，如果你是在解决一个确切的问题，
直接跳到这个日志文件的末尾，那里有 `FUNCTIONS SORTED ON TOTAL TIME` 和 `FUNCTIONS SORTED ON SELF TIME` 两个部分，如果某个 function 运行时间过长一眼就可以看到。
