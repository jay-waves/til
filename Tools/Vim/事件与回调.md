你可以触发任何事件，如：`:doautocmd BufRead`。


### 用户自定义事件

对于插件而言，创建你自己的自定义事件有时非常有用。

```vim
function! Chibby()
    " A lot of stuff is happening here.
    " And at last..
    doautocmd User ChibbyExit
endfunction
```

现在你插件的用户可以在 Chibby 执行完成之后做任何他想做的事情：

```vim
autocmd User ChibbyExit call ChibbyCleanup()
```

顺便提一句，如果在使用 `:autocmd` 或 `:doautocmd` 时没有捕捉异常，那么会输出 "No matching autocommands" 信息。这也是为什么许多插件用 `silent doautocmd ...` 的原因。但是这也会有不足，那就是你不能再在 :autocmd 中使用 `echo "foo"` 了，取而代之的是你要使用 `unsilent echo "foo"` 来输出。

这就是为什么要在触发事件之前先判断事件是否存在的原因，

```vim
if exists('#User#ChibbyExit')
  doautocmd User ChibbyExit
endif
```

帮助文档：`:h User`

### 事件嵌套

默认情况下，自动命令不能嵌套！如果某个自动命令执行了一个命令，这个命令再依次触发其它的事件，这是不可能的。

例如你想在每次启动 Vim 的时候自动打开你的 vimrc 文件：

```vim
autocmd VimEnter * edit $MYVIMRC
```

当你启动 Vim 的时候，它会帮你打开你的 vimrc 文件，但是你很快会注意到这个文件没有任何的高亮，尽管平时它是正常可以高亮的。

问题在于你的非嵌套自动命令 `:edit` 不会触发“BufRead”事件，所以并不会把文件类型设置成“vim”，进而 `$VIMRUNTIME/syntax/vim.vim` 永远不会被引入。详细信息请参考：`:au BufRead *.vim`。要想完成上面所说的需求，使用下面这个命令：

```vim
autocmd VimEnter * nested edit $MYVIMRC
```

帮助文档：`:h autocmd-nested`


## 打开文件时恢复光标位置

如果没有这个设置，每次打开文件时光标都将定位在第一行。而加入了这个设置以后，你就可以恢复到上次关闭文件时光标所在的位置了。

将下面的配置添加到你的 vimrc 文件：

```vim
autocmd BufReadPost *
    \ if line("'\"") > 1 && line("'\"") <= line("$") |
    \   exe "normal! g`\"" |
    \ endif
```

这是通过判断之前的光标位置是否存在（文件可能被其它程序修改而导致所记录的位置已经不存在了），如果存在的话就执行 `` g`" `` （转到你离开时的光标位置但是不更改跳转列表）。

这需要使用 viminfo 文件：`:h viminfo-`。

## 快速跳转到源(头)文件

这个技巧可以用在多种文件类型中。当你从源文件或者头文件中切换到其他文件的时候，这个技巧可以设置「文件标记」（请参阅 `:h marks`），然后你就可以通过连续按下 <kbd>'</kbd> <kbd>C</kbd> 或者 <kbd>'</kbd> <kbd>H</kbd> 快速跳转回去（请参阅 `:h 'A`）。

```vim
autocmd BufLeave *.{c,cpp} mark C
autocmd BufLeave *.h       mark H
```

**注意**：由于这个标记是设置在 viminfo 文件中，因此请先确认 `:set viminfo?` 中包含了 `:h viminfo-'`。

