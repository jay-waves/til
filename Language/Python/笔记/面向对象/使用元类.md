# MetaClass, 元类

元类定义了类的模板, 所有类基于 `object`, 而所有元类基于 `type`

```python
class Meta(type):
	def __new__(cls, name, bases, dct):
		x = super().__new__(cls, name, bases,  dct)
		pass

class MyObject(object):
	pass
```

## 直接使用属性而不是 Get/Set 方法

其他面向对象语言天然要求保护内部属性, 使用 `get` 和 `set` 方法对内部属性进行读写.  
在 Python 中, 应一切从简, 避免 `mycls.get_attr1()` 这样笨拙地使用方式. 如果封装是必要的, 应使用 Python 提供的装饰器方法, 使通过类方法读写内部属性变得和直接访问一样自然. 

```python
class Resistor:
	def __init__(self, ohms):
		self.ohms = ohms
		self.voltage = 0
		self.current = 0
		
class VoltageResistance(Resistor):
	def __init__(self, ohms):
		super().__init__(ohms)
		self._voltage = 0

	@property
	def voltage(self):
		return self._voltage

	@voltage.setter
	def voltage(self, voltage):
		self._voltage = voltage
		self.current = self._voltage / self.ohms

	@property
	def ohms(self):
		return self._ohms
		
	@ohms.setter
	def ohms(self, ohms):
		if ohms <= 0:
			raise ValueError("ohms must be > 0")
		self._ohms = ohms

r1 = VoltageResistance(1e3)
print(r1.current) # use property
r1.voltage = 10   # use voltage.setter

r2 = VoltageResistance(-5) 
>> ValueError: ohms must be > 0

# use @setter to make property immutable
class FixedResistance(Resistor):
	...
	@ohms.setter
	def ohms(self, ohms):
		if hasattr(self, '_ohms'):
			raise AttributeError("Can't set attribute")
		self._ohms = ohms

# follow the rule of **least surprise** while using @property
```

示例:
```python
class Bucket:
	def __init__(self, period):
		self.period_delta = timedelta(seconds=period)
		self.reset_time = datetime.now()
		# self.quota = 0
		self.max_quota = 0
		self.quota_consumed = 0
		
	def __repr__(self):
		# return 'Bucket(quota=%d)' %self.quota
		return (f'Bucket(max_quota={slef.max_quota}, \
				quota_consumed={self.quota_consumed}')

	@property
	def quota(self):
		return self.max_quota - self.quota_consumed

	@quota.setter
	def quota(self, amount):
		delta = self.max_quota - amount
		if amount == 0:
			self.quota_consumed = 0
			slef.max_quota = 0
		elif delta < 0:
			assert self.quota_consumed == 0
			self.max_quota = amount
		else:
			assert self.max_quota >= slef.quota_consumed
			self.quota_consumed += delta

	def fill(bucket, amount):
		now = datetime.now()
		if now - bucket.reset_time > bucket.period_delta:
			bucket.quota = 0
			bucket.reset_time = now
		bucket.quota += amount
		
	def deduct(bucket, amount):
		now = datetime.now()
		if now - bucket.reset_time > bucket.period_delta:
			return False
		if bucket.quota < amout:
			return False
		bucket.quota -= amount
		return True

bucket = Bucket(60) # fill the bucket
fill(bucket, 100)
if deduct(bucket, 99):
	print('Had 99 quota')
else:
	print('Not enough for 99 quota')
```

## Descriptor

`@property` 在复用时存在一些问题, 此时可用 Python Descriptor 协议.

```python
class Grade:
	def __init__(self):
		# 为避免内存泄露, 使用 weakKeyDict. 
		# 当它意识到仅有自己持有某对象的引用, 就会自动删除该对象
		self._value = WeakKeyDictionary()
	def __get__(self, instance, instance_type):
		if instance is None: return self
		return self._values.get(instance, 0)
	def __set__(self, instance, value):
		if no (0<= value <=100):
			raise ValueError
		# 由于会保存一个对 instance 的引用, 会造成内存泄漏.
		self._value[instance] = value

class Exam:
	# 注意, 类属性被所有 Exam 实例共享. Grade 通过将值和实例绑定来区分.
	math_grade = Grade()
	writing_grade = Grade()
	science_grade = Grade()


exam = Exam()
exam.writing_grade = 40
# same as Exam.__dict__['writing_grade'].__set__(exam, 40)
```

### 处理惰性成员

惰性成员, Lazy Attributes. 即仅当访问时, 才创建或读取.

```python
'''
Python 中, 访问类属性时, 检查逻辑是这样的:
1. find attr in __dict__, return if found
2. try __getattribute__
3. catch Attribute: try __getattr__
'''
```

```python
class LazyDB:
	def __init__(self):
		self.exists = 5
	def __getattr__(self, name):
		value = 'Value for %s' %name
		setattr(self, name, value)
		return value
	def __getattribute__(self):

data = LazyDB()
data.foo # 当属性不存在时, 自动创建为 "Value for foo"

class ValidatingDB:
	def __init__(self):
		self.exists = 5
	def __getattribute__(self, name):
		print(f'Called __getattribute__{name}')
		try:
			return super().__getattribute__(name)
		except AttributeError:
			value = f"Value for {name}"
			setattr(self, name, value)
			return value
	def __setattr__(slef, name, value):
		super().__setattr__(name, value)
		print(f'Called __setattr__{name}, with value {value}')

hasattr(data, 'foo')
getattr(data, 'foo')
setattr(data, 'foo', 4)
```

Python 的所有类的基类是 `object`, 使用 MRO (Method Resolution Order) 来处理多态:
1. 当前类的 MRO 是 `[当前类, 父类 MRO]`, 顶层类 MRO 为: `[顶层类, object]`.
2. 按广度优先的顺序来合并各个父类的 MRO, 确保每种类仅出现一次 (避免菱形继承).
3. 合并父类 MRO 时, 保证子类顺序应优先于父类.
4. 使用 `super()` 方法实际就是调用了 MRO 解析顺序.

```python
#! 使用 __getattribute__ 和 __setattr__ 时, 要特别小心无限循环.
def __getattribute__(self, name):
	return self._data # 栈将溢出

# 解决办法是利用 MRO
def __getatrribute__(self, name):
	rdata = super().__getattribute__('_data')
	return rdata
```

## 使用元类注册类实例

```python
class Serializable(object):
	def __init__(self, *args):
		self.args = args
	def serialize(self):
		return json.dumps({'args': self.args})
		
class Point2D(Serializable):
	def __init__(self, x, y):
		super().__init__(x, y)
		self.x = x
		self.y = y

	def __repr__(self):
		return 'Point2D(%d, %d)' %(self.x, self.y)

point = Point2D(5,3)
print("Object: ", point)
print("Serialized: ", point.serialize())
>>> Object: Point2D(5, 3)
>>> Serialized: {"args": [5,3]}
```