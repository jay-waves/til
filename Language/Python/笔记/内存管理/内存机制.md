python变量, 实质上是对"(内存)对象"的一种引用. 其本质是一种指向"对象"的指针, 也不具备具体类型.

## 对象
1. 对象有类型
2. 对象是内存的一块空间
3. 每个对象都有两个标准头部信息:
	- 类型标志符: 标识对象类型
	- 引用计数器: 用来判断是否回收该对象的内存

对于编程人员, 同理python对象有三个要素:
- id: 唯一标识一个对象
- type: 对象的类型
- value: 对象的值

> a is b 比较的是 id(即id(a)\=\=id(b)),  a\=\=b 比较的是value
> 一些低位整数和短字符串提前被缓存在内存中, 以备复用. 这些对象的引用次数非常高, 因为系统引用了他们很多.可以使用sys库中`.getrefcount()`方法去查询对象究竟被引用了多少次, 比如`print(sys.getrefcount(1))`

当对一个变量进行多次不同对象赋值, 实际上是更改了引用. 而没有更改对应的对象. 

## 可变或不可变对象
- 可变对象
如list, set, dict
内存对象的值可以改变, list中的元素就存在list对象中.

- 不可变对象
如int, float, complex, str, bool, tuple, frozenset
内存对象的值不可改变.

**两者核心区别体现在内在机制上, 可变对象可以修改, 直接修改在其原对象上; 不可变对象也可以修改, 但是一旦修改, 就会产生一个新的修改后的对象, 并将引用改到新对象上, 原对象不变, 通过引用计数器判断是否将其回收.**

## 深浅拷贝
- 浅层拷贝 `arr[:]`
- 深层拷贝`import copy, copy.deepcopy(arr)`
两者区别的核心在于: "深层拷贝"是"递归式的浅层拷贝", 两者在类似嵌套列表的结构中表现有差异:
```python
a = [1, [1, 2], 3]
b = a[:] #浅拷贝, 对于嵌套其中的列表则只复制其引用, 而不克隆一份新的对象
a[1][1] = 9
print(b) 

>>> [1, [1, 9], 3]
```

```python
import copy
a = [1, [1, 2], 3]
b = copy.deepcopy(a) #深层拷贝, [1,2]不是仅仅复制一个引用, 而是创建了一个新的列表对象
a[1][1] = 9
print(b) 

>>> [1, [1, 2], 3]
```
