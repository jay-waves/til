python话说会自己管理内存，实际上，对于**占用很大内存的对象，并不会马上释放**。举例，a=range(10000\*10000)，会发现内存飙升一个多G，del a 或者a=\[\]都不能将内存降下来。。
  
- 办法：  
```python
import gc （garbage collector）  
del a  #del a, b, c, d
gc.collect()  
```
马上内存就释放了。

在IPython中用run运行程序时，都是在独立的运行环境中运行，结束之后才将程序运行环境中的结果复制到IPython环境中，因此不会有变量被重复调用的问题。

在自己的程序中想删除所有全局变量的话，可以编写一个clear函数，通过globals()获取全局变量然后将其中不需要的内容删除，例如下面的程序保留函数，类，模块，删除所有其它全局变量：

```python
def clear():
    for key, value in globals().items():
        if callable(value) or value.g__class__.__name__ == "module":
            continue
        del globals()[key]
```

不过程序中应该避免这种对全局变量的依赖。你也可以在IPython下用此函数清空全局变量。

***

> 以下摘自vamei：http://www.cnblogs.com/vamei/p/3232088.html

在Python中，**整数和短小的字符，Python都会缓存这些对象**，以便重复使用。当我们创建多个等于1的引用时，实际上是让所有这些引用指向同一个对象。

```python
a = 1
b = 1

print(id(a))
print(id(b))
```

上面程序返回
```
11246696
11246696
```

可见a和b实际上是指向同一个对象的两个引用。

为了检验两个引用指向同一个对象，我们可以用is关键字。is用于判断两个引用所指的对象是否相同。

```python
# True
a = 1
b = 1
print(a is b)

# True
a = "good"
b = "good"
print(a is b)

# False
a = "very good morning"
b = "very good morning"
print(a is b)

# False
a = []
b = []
print(a is b)
```

上面的注释为相应的运行结果。可以看到，由于Python缓存了整数和短字符串，因此每个对象只存有一份。比如，所有整数1的引用都指向同一对象。即使使用赋值语句，也只是创造了新的引用，而不是对象本身。长的字符串和其它对象可以有多个相同的对象，可以使用赋值语句创建出新的对象。

在Python中，每个对象都有存有指向该对象的引用总数，即引用计数(reference count)。

我们可以使用sys包中的getrefcount()，来查看某个对象的引用计数。需要注意的是，当使用某个引用作为参数，传递给getrefcount()时，参数实际上创建了一个临时的引用。因此，getrefcount()所得到的结果，会比期望的多1。

```
from sys import getrefcount

a = [1, 2, 3]
print(getrefcount(a))b = aprint(getrefcount(b))
```

由于上述原因，两个getrefcount将返回2和3，而不是期望的1和2。

### 对象引用对象

Python的一个容器对象(container)，比如表、词典等，可以包含多个对象。实际上，容器对象中包含的并不是元素对象本身，是指向各个元素对象的引用。

我们也可以自定义一个对象，并引用其它对象:

```python
class from_obj(object):
    def __init__(self, to_obj):
        self.to_obj = to_obj

b = [1,2,3]
a = from_obj(b)
print(id(a.to_obj))
print(id(b))
```


可以看到，a引用了对象b。

对象引用对象，是Python最基本的构成方式。即使是a = 1这一赋值方式，实际上是让词典的一个键值"a"的元素引用整数对象1。该词典对象用于记录所有的全局引用。该词典引用了整数对象1。我们可以通过内置函数globals()来查看该词典。

当一个对象A被另一个对象B引用时，A的引用计数将增加1。


```python
from sys import getrefcount

a = [1, 2, 3]
print(getrefcount(a))

b = [a, a]
print(getrefcount(a))
```


由于对象b引用了两次a，a的引用计数增加了2。

当垃圾回收启动时，Python扫描到这个引用计数为0的对象，就将它所占据的内存清空。

然而，减肥是个昂贵而费力的事情。垃圾回收时，Python不能进行其它的任务。频繁的垃圾回收将大大降低Python的工作效率。如果内存中的对象不多，就没有必要总启动垃圾回收。所以，Python只会在特定条件下，自动启动垃圾回收。当Python运行时，会记录其中分配对象(object allocation)和取消分配对象(object deallocation)的次数。当两者的差值高于某个阈值时，垃圾回收才会启动。

我们可以通过gc模块的`get_threshold()`方法，查看该阈值:

```python
import gc
print(gc.get_threshold())
```

返回(700, 10, 10)，后面的两个10是与分代回收相关的阈值，后面可以看到。700即是垃圾回收启动的阈值。可以通过gc中的`set_threshold()`方法重新设置。

我们也可以手动启动垃圾回收，即使用`gc.collect()`。

### 分代回收

Python同时采用了分代(generation)回收的策略。这一策略的基本假设是，存活时间越久的对象，越不可能在后面的程序中变成垃圾。我们的程序往往会产生大量的对象，许多对象很快产生和消失，但也有一些对象长期被使用。出于信任和效率，对于这样一些“长寿”对象，我们相信它们的用处，所以减少在垃圾回收中扫描它们的频率。

Python将所有的对象分为0，1，2三代。所有的新建对象都是0代对象。当某一代对象经历过垃圾回收，依然存活，那么它就被归入下一代对象。垃圾回收启动时，一定会扫描所有的0代对象。如果0代经过一定次数垃圾回收，那么就启动对0代和1代的扫描清理。当1代也经历了一定次数的垃圾回收后，那么会启动对0，1，2，即对所有对象进行扫描。

这两个次数即上面`get_threshold()`返回的`(700, 10, 10)`返回的两个10。也就是说，每10次0代垃圾回收，会配合1次1代的垃圾回收；而每10次1代的垃圾回收，才会有1次的2代垃圾回收。

同样可以用`set_threshold()`来调整，比如对2代对象进行更频繁的扫描。

```python
import gc
gc.set_threshold(700, 10, 5)
```