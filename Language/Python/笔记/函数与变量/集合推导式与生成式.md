### list comprehension

在列表中直接使用表达式
```python
a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 
squares = [x**2 for x in a] 
print(squares) 

>>> [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
```

**缺陷**: 每次执行都会创造一个新列表, 直接加载所有元素到内存中, 可能占大量内存 (要用它遍历, 就需要把所有这些新的列表都存起来, python往往不能释放掉这部分内存). 

> 具体见[[../内存管理/内存管理]]

应用:
- 创建等长空列表: `[0 for _ in list]`
- 奇数0偶数1: `[1 if i%2==0 else 0 for i in range(n)]

### generator expression

生成器提供了一种延迟计算的方式. 将数据定义为[枚举器](返回值使用迭代器而不是列表.md), 然后仅在实际请求时才(惰性)生成, 并不直接加载入内存.  使用方法就是用 `()` 替代推导式的 `[]`

e.g.
```python
it = (len(x) for x in open(‘/tmp/my_file.txt’))
#注意it此时是一个枚举类型, 不是常规数据类型
roots = ((x, x**0.5) for x in it)
#此处使用了嵌套(chain), 这样的速度也很快
print(next(roots))

>>> (15, 3.872983346207417) #output

# 生成式并不是生成了元组! 元组这样推导:
tuple(x**2 for x in range(5))
```

**缺陷**: 枚举器是消耗品, 只能使用一次. *但, 嵌套使用非常快*.

### enumerate

遍历时经常使用range. 有时想遍历sequence类型(list等), 又想要直到其序号, 就会使用`range(len(my_list))`这种表达形式, 但是使用enumerate()是更简洁的形式:

```python
for i, flavor in enumerate(flavor_list): 
	print(‘%d: %s’ % (i + 1, flavor))
```

其第二参数为"从哪里开始": `enumerate(my_list, begin_pos)`