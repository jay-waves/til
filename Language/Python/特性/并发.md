CPython 为确保抢占式线程不会破坏解释器对资源的管理, 使用 GIL (Global Interpreter Lock) 确保线程安全, 同一时间只能一个线程执行 Python 字节码, 所以 Python 是 **并发 (concurrency)**, 而不是并行 (parallelism).

对于 IO 密集型任务 (文件IO或网络请求), 线程可以释放 CPU 使用权 (GIL) 来等待任务完成, 所以效率较高. 但对 CPU 密集任务, 多线程不会加速反而带来额外上下文切换开销. 

解决方法有: 使用 Jython/IronPython 这样的无 GIL 的 Python 实现, 或使用非 GIL 依赖库 (如 `numpy`, `concurrent.futures`).

|                    | Multi-Threads       | Multi-Processes |
| ------------------ | ------------------- | --------------- |
| Python Interpreter | share               | multi           |
|   mode                 | Concurrency         | Parallelism     |
| Applicable Scene   | I/O, Network Request | Computing       |
| CPU Core           | one                 | multi           |
| Python Speedup            | no                  | yes                |


## 多进程

[subprocess](../标准库/subprocess.md)

## 多线程

