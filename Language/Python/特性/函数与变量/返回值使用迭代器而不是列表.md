函数返回值想要列表 list 形式时, 应用 generator 替代.
这样的好处是: 
- 比处理列表更加简洁, 也更加高效
- generator 不会占用大量工作内存, 可以更好的应对大型数据

缺点是返回的迭代器只能使用一次, 见 [迭代器无法重用](勿重用迭代器.md). 可以用 `next()` 获取迭代器, 但更推荐 `list()` 直接生成整个列表

普通形式: 
```python
def index_words(text):
	result = []
	if text:
		result.append(0)
	for index, letter in enumerate(text):
		if letter == ' ':
			result.append(index + 1)
	return result
```

使用 generator 形式: 函数中将 iterator 递回给 `yield`
```python
def index_words_iter(text):
	if text:
		yield 0
	for index, letter in enumerate(text):
		if letter == ' ':
			yield index + 1
```

使用迭代器yield构造的函数, 运行机制有所不同. 它不是全部运行完后再调回, 当对其调用时, 并不立即执行而是保留在栈中, 直到外部单独调用iterator, 才开始一个一个的执行(`next()`). 

当然, 使用 `list()` 可以加速 iterator 的生成, 但超大数据时对内存的保护就消失了, 例如 `result = list(index_words_iter(address))`