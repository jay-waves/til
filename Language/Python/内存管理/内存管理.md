python变量, 实质上是对"(内存)对象"的一种引用. 其本质是一种指向"对象"的指针, 也不具备具体类型.

## 对象

1. 对象有类型
2. 对象是内存的一块空间
3. 每个对象都有两个标准头部信息:
	- 类型标志符: 标识对象类型
	- 引用计数器: 用来判断是否回收该对象的内存

python 对象有三个要素:
- id: 唯一标识一个对象
- type: 对象的类型
- value: 对象的值

> `a is b` 等价于 `id(a) = id(b)`, `a==b` 则是纯值比较
> 
> 某些低位整数和短字符串提前被缓存在内存中, 以备复用. 这些对象的引用次数非常高.
> 
> `sys.getrefcount()` 查询对象被引用次数, 如 `sys.getrefcount(1)`

当对一个变量进行多次不同对象赋值, 实际上是更改了引用. 而没有更改对应的对象. 

## 可变或不可变对象

- 可变对象, 如: `list, set, dict`, 内存对象的值可以改变.

- 不可变对象, 如: `int, float, str, bool, tuple`, 内存对象的值不可改变.

两者核心区别体现在内在机制上:
- 可变对象可以修改, 直接修改在其原对象上.
- 不可变对象也可以修改, 但实际行为是声明新对象后将引用赋值给同名变量.
- 被修改的原不可变对象, 若引用计数为空, GC 自动将其内存收回.
- 赋值时(而不是拷贝), Python 仅将引用绑定到变量名上.

## 拷贝

拷贝和赋值不同, 拷贝会将引用所指的对象复制一份.

- 浅层拷贝 `arr[:]`
- 深层拷贝 `import copy, copy.deepcopy(arr)`, 递归地浅拷贝.

```python
a = [1, [1, 2], 3]
b = a[:] #浅拷贝, 对于嵌套其中的列表则只复制其引用, 而不克隆一份新的对象
a[1][1] = 9
print(b) 

>>> [1, [1, 9], 3]
```

```python
import copy
a = [1, [1, 2], 3]
b = copy.deepcopy(a) #深层拷贝, [1,2]不是仅仅复制一个引用, 而是创建了一个新的列表对象
a[1][1] = 9
print(b) 

>>> [1, [1, 2], 3]
```
