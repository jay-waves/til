## 静态类型

在**编译时**确定变量类型, 并检查类型错误. 编译时即捕获错误, 提高程序可靠性与性能.

```c
int x = 10;
char *s = "hello\n"
```

### 显式类型

Manifest Typing. 要求在源码中明确声明每个变量和函数的类型. 显式语言一般为静态语言, 但是有的静态语言支持类型推断 (如 c++ auto).

## 动态类型

在**运行时**确定变量的类型, 并检查类型错误. 更灵活. 

```python
x = 10
x = "Now x is a string"
```

动态类型系统中, 通常不需要用户明确指定类型, 即使用隐式类型 (implicit typing), 由解释器自动推断变量类型; 当然, C++等静态类型语言也有自动类型推导功能 `auto`, 不过是在编译阶段完成的.

```typescript
// 虽然 typescript 添加了静态类型, 但是仍允许类型推断
let x = 10;
```


## 强/弱类型

强类型系统 (strong typing) 要求**显式声明变量类型转换**

```python
x = 10
y = "20"
x + y # TypeError
```

弱类型系统 (weak typing) 允许更多隐式转换:

```javascript
var x = 10;
var y = "20"
console.log(x + y); // "1020"
```

## 泛型

编写类型无关代码, 从而提高代码可用性. 如 C++ 虽然是静态语言, 但模板编程增加了其表达能力, 注意 C++ 模板通过编译期间对每种可能类型自动复制一份类似代码来实现 (和 `inline` 道理类似, 增加编译工作和嵌入代码体积, 增加运行时性能).

```java
public class Box<T> {
	private T value;
	public void setValue(T value) {
		this.value = value;
	}
	public T getValue() {
		return value;
	}
}
```

### Duck Typing

一个东西"看起来像鸭子, 走起来也像鸭子", 那么它就是鸭子. 常见于动态语言的泛型支持, 和 GO 语言的接口概念有点类似.

```python
class Duck:
	def quack(self):
		print("Quack")

class Person:
	def quack(self):
		print("Quacking like duck")

def quacking(thing):
	thing.quack()
```