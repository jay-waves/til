
## 类继承

```cpp
class Animal{
	...
}

class Cost{
	...
}

class Cat: public Animal, public Cost{
	...
}
```

## 友类

访问控制权限:

| 访问   | public | protected | private |
| ------ | ------ | --------- | ------- |
| 同一类 | Y      | Y         | Y       |
| 子类   | Y      | Y         | N       |
| 外部类 | Y      | N         | N       |
| 友类   | Y      | Y         | Y        |

```cpp
class A{
public:
	friend class B;
private:
	int m_;
}

class B{
public:
	void get_m(A& a) {cout << a.m_}
}
```
- 友元关系不是相互的, 即A声明B为友元, 那么A能访问B的所有成员, 而B不能访问A.
- 友元关系无法继承

## 多态

c++ 多态指: 父类使用 `vitual` 声明一虚函数, 而不给出具体实现, 不同子类对同一父类方法进行不同实现. c++ 虚函数本质是使编译器不静态链接导到函数, 而是运行时动态链接.

```cpp
class Animal{
public:
	virtual void f();
	virtual void g() = 0; // 纯虚函数, 即父类不会实际定义, 子类必须定义.
	// 声明纯虚函数的类称为抽象类, 不能被实例化.
	virtual void h() override; // 用于子类重载父类函数.
	virtual void k() override final; // final 指后续派生类不能再重定义该函数.
}
```

即使是同一类, 借助 [c++ 函数签名包含参数的特性](../../../../Compiler/Linking/符号.md), 类也可以有同名方法. 比如, 多种(参数不同的)初始化方法:

```cpp
class Person{
	public:
		Person() = delete; // Person p1{}, p2(), p3
		Person(const Person&) = default;  // Person p4{p1}, p5(p2)
		Person& operator= (const Person&) = delete; // 符号重载, Person p6; p6=p1
		Person(Person&&) = delete; // Person p7{std::move(p2)};
		Person& operator= (Person&&) = delete; // Pserson p8; p8=std::move(p3)
		~Person() = delete; // 析构函数
}
```

利用符号重载, 可以让类行为更加自然:
```cpp
class Person{
public:
	bool operator== (const Person& rhs) {
		return getName() == rhs.getName();
	}
	Person& operator=(const Person& rhs){
		if (this != &rhs) 
			this->value = rhs.value;
		return *this
	}
}
```

rhs 代表右值, 见 [C++/特性/左值右值](../内存管理/拷贝和移动语义.md)

### 虚函数实现方式

通过*虚函数表 (vtbl)*, c++ 在运行时确定虚函数的实际调用位置. 比直接函数调用慢 25%, 额外占用每个对象一个字节, 存储指针指向虚函数表; 每种类还额外有一个虚函数表体积.

```cpp

// 基类的虚函数表结构
struct AnimalVTable {
  void (*speak)(void*);
  void (*move)(void*);
};

// 基类
class Animal {
 public:
  Animal(const std::string& name) : name_(name) {
    // 初始化虚函数表指针
    vtable_ = &animal_vtable_;
  }
  
  // 非虚析构函数 - 通常应该是虚拟的，但这里为了演示简化
  ~Animal() = default;
  
  // 对外公开的接口函数
  void Speak() const {
    vtable_->speak(const_cast<void*>(static_cast<const void*>(this)));
  }
  
  void Move() const {
    vtable_->move(const_cast<void*>(static_cast<const void*>(this)));
  }
  
 protected:
  // 虚函数表指针
  AnimalVTable* vtable_;
  
  // 基类虚函数实现
  static void SpeakImpl(void* self) {
    Animal* animal = static_cast<Animal*>(self);
    std::cout << animal->name_ << " makes a sound" << std::endl;
  }
  
  static void MoveImpl(void* self) {
    Animal* animal = static_cast<Animal*>(self);
    std::cout << animal->name_ << " moves" << std::endl;
  }
  
  // 静态虚函数表
  static AnimalVTable animal_vtable_;
  
  // 成员数据
  std::string name_;
};

// 初始化基类静态虚函数表
AnimalVTable Animal::animal_vtable_ = {
  Animal::SpeakImpl,
  Animal::MoveImpl
};

// 派生类Dog
class Dog : public Animal {
 public:
  Dog(const std::string& name, int leg_count) 
      : Animal(name), 
        leg_count_(leg_count) {
    // 覆盖虚函数表指针
    vtable_ = &dog_vtable_;
  }
  
 private:
  // 派生类虚函数实现
  static void SpeakImpl(void* self) {
    Dog* dog = static_cast<Dog*>(self);
    std::cout << dog->name_ << " barks! Has " 
              << dog->leg_count_ << " legs" << std::endl;
  }
  
  static void MoveImpl(void* self) {
    Dog* dog = static_cast<Dog*>(self);
    std::cout << dog->name_ << " runs on " 
              << dog->leg_count_ << " legs" << std::endl;
  }
  
  // 静态虚函数表
  static AnimalVTable dog_vtable_;
  
  // 派生类特有成员
  int leg_count_;
};

// 初始化Dog静态虚函数表
AnimalVTable Dog::dog_vtable_ = {
  Dog::SpeakImpl,
  Dog::MoveImpl
};

// 派生类Bird
class Bird : public Animal {
 public:
  Bird(const std::string& name, int wing_span) 
      : Animal(name), 
        wing_span_(wing_span) {
    // 覆盖虚函数表指针
    vtable_ = &bird_vtable_;
  }
  
 private:
  // 派生类虚函数实现
  static void SpeakImpl(void* self) {
    Bird* bird = static_cast<Bird*>(self);
    std::cout << bird->name_ << " chirps! Wing span: " 
              << bird->wing_span_ << " cm" << std::endl;
  }
  
  static void MoveImpl(void* self) {
    Bird* bird = static_cast<Bird*>(self);
    std::cout << bird->name_ << " flies with a wing span of " 
              << bird->wing_span_ << " cm" << std::endl;
  }
  
  // 静态虚函数表
  static AnimalVTable bird_vtable_;
  
  // 派生类特有成员
  int wing_span_;
};

// 初始化Bird静态虚函数表
AnimalVTable Bird::bird_vtable_ = {
  Bird::SpeakImpl,
  Bird::MoveImpl
};
```