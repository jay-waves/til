
并发的模式:
1. 从硬件能力: 并行, 并发, [GPU并行](CUDA.md)
2. 从资源规模: [进程, 线程](../../../System/Process/进程与线程.md), 协程. 
3. 从任务类型: 计算密集型 (CPU-bound), I/O密集型 (I/O-bound), 数据密集型 (同类数据的并行处理, 如像素矩阵和数据分析), 任务密集型 (使用分布式系统, 处理大量关联较弱的任务, 如不同网络用户的请求). **主要目的是提高计算速度和响应速度, 避免等待和卡顿**.
4. 从[通信和同步模式](../../../System/IPC/ReadMe.md): 异步共享内存, 同步共享内存, 异步消息传递, 同步消息传递

进程相关: 操作系统负责管理进程, 而不是编程语言, 编程语言通过封装操作系统的*进程通信与同步*相关的系统调用, 来向上提供管理进程的功能. 除了 C/C++, 其他通常不好用.
- 进程间通信 [IPC](../../../System/IPC/ReadMe.md)
- [进程调度](../../../System/Process/进程调度.md)
- [进程同步与互斥](../../../System/Process/进程同步与互斥.md)

线程相关: 线程间同步涉及对**同一进程下的共享内存**的访问控制. 从语言实现方面, 线程可能是并行也可能是并发 (Python), 协程是并发.
- [互斥锁与信号量](../../../System/Process/进程同步与互斥.md#信号量)
- [条件变量](../../../System/Process/进程同步与互斥.md#条件变量)
- [读写锁](../../../System/Process/进程同步与互斥.md#读写锁)

协程相关: 线程阻塞时让出 CPU, 是交由操作系统调度器处理的; 而协程是**用户态调度**的, 通过关键字 `yield, await` 主动让出 CPU. 协程也称为用户态线程. 协程本质是单线程的并发协调技术, 不同实现方式间有较大区别.
- Promise/Future 模型, Async/Await 模型. 都是 事件+回调 的同步方式.
- [Python](../../Python/并发执行/并发.md) 使用生成器来模拟协程, 生成器每次 `yield` 后会暂停, 和协程等待的概念很类似. 虽然但是 pyhton 也提供了原生的 [asyncio](../../Python/并发执行/asyncio.md)
- [Go](../../Go/Go%20并发.md) 使用 Goroutine 轻量协程概念, 并提供了 `channel` 来进行阻塞/非阻塞通信.
- 异步I/O

异步I/O方式(事件驱动+回调)和协程的概念有一些区别, 但是可以用异步I/O来模拟协程. 如: Async/Await 是 Promise/Future 的封装, 但是 async/await 在语义上更接近协程概念.



***


PS: C++ 的协程库巨难用.