

## 拷贝语义

C++ 默认的拷贝是*浅拷贝*. 如果需要*深拷贝*, 需要手动实现*拷贝构造函数 (copy constructor)* 和*拷贝赋值函数 (copy assignment)*.

```cpp
class Vector {
private:
	double *elem_;
	int size_;
public:
	Vector(int s);
	~Vector() { delete[] elem_; }

	// copy constructor
	Vector(const Vector& a) : elem_{new double[a.size_]}, size_{a.size_} {
		for (int i = 0; i != size_; ++i)
			elem_[i] = a.elem_[i];
	}
	// copy asignment 
	Vector& operator=(const Vector& a) {
		double *p = new double[a.size_];
		for (int i = 0; i != a.size_, ++i)
			p[i] = a.elem_[i];
		delete[] elem_;
		elem_ = p;
		size_ = a.size_;
		return *this;
	}

	double& operator[](int i);
	const double& operator[](int i) const;
};
```

## 移动语义

```cpp
class Vector {
	// ...
	// move constructor
	Vector(Vector&& a) : elem_{a.elem_}, size_{a.size_} {
		a.elem_ = nullptr;
		a.size_ = 0;
	}
	// move assignment
	Vector& operator=(Vector&& a);

	// ...
};
```

### 完美转发

*完美转发*, 指同时支持左值调用和右值调用. 当传入的模板参数是 `T&&` 时, 编译器自动推导实参类型, 将左值实参推导为 `T&`, 将右值实参推导为 `T`. 在 C++11 中, 右值引用 `&&` 和模板参数 `T` 同时出现时, 变为 Forwarding Reference (Universal Reference). 

```cpp 
template <typename T>
void wrapper(T&& arg) {
	callee(std::forward<T>(arg));
}

int x = 10;
wrapper(x);  // 左值调用
wrapper(29); // 右值调用
```

完美转发比 `const T&` 更灵活. 因为 `T&&` 支持移动语义, 可以接管所有权. 并且 `T&&` 也同时支持右值与左值引用.