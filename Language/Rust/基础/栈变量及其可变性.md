## Mutability

- 默认不可变变量: `let x=5;`
- 可变变量: `let mut x=5;`
- 常量: `const X: u32 = 5;`, 常量必须在编译期确定, 作用域可更广.

```rust
let x=5;
x = 6; //Error!
```

## Shadowing

虽然不可变变量 `x` 本身值不可变, 但是可以声明同名变量来覆盖它:

```rust
let x = 5;
// x->5
let x = x+1;
// x->6
{
	let x = x*2;
	// x->12
}
// x->6
```

同名变量可以不保持类型, 但是可变变量必须保持类型

## Types

Rust 是静态类型语言.

### Scalar Types

rust 变量类型有四种: integer, floating-point number, boolean, charaters

Integer 类型如下, 有符号整型按 [补码格式](https://en.wikipedia.org/wiki/Two%27s_complement) 存储.

| Length | Signed | Unsigned |
| ------ | ------ | -------- |
| `8b`   | i8     | u8       |
| `16b`  | i16    | u16      |
| `32b`  | i32 (default)    | u32      |
| `64b`  | i64    | u64      |
| `128b` | i128   | u128     |
| arch   | isize  | usize         |

Integer 字面量有多种表示方法:

| Literals       | Example       |
| -------------- | ------------- |
| Decimal        | `98_222`      |
| Hex            | `0xff`        |
| Octal          | `0o77`        |
| Binary         | `0b1111_0000` |
| Byte (`u8` only) |               `b'A'`|

Float 类型有 `f32` 和 `f64`, `f64` 为默认类型. 使用 *IEEE-754* 标准存储, `f64` 为双精度浮点数, `f32` 为单精度.

Boolean 类型: 占1字节, 值有 `ture` 或 `false`

Char 类型: 占4字节, 用 Unicode 编码. char 使用 `''`, string 使用 `""`

其他特殊类型: 未定义 `nan` (not a number)

### Compound Types

#### Tuple

元组有固定长度, 但是组内元素类型不必一致.

```rust
let tup: (i32, f64, u8) = (500, 6.4, 1);

let (x,y,z) = tup; // pattern matching

let one = tup.2; // visit by index
```

无具体值的元组称为单元 (unit): `()`, 表达式如无返回值, 会默认返回单元.

#### Array

数组内元素类型必须一致, 且有固定长度. 数组存储在栈上.

```rust
let a: [i32; 5] = [1, 2, 3, 4, 5];

// with default same value: [3,3,3,3]
let a = [3; 4]

// visit
let first = a[0];
```

rust 会在运行时检查数组越界.

## Operations

State data type:
```rust
let var: i32 = 10;
// same as:
let var = 10_i32;
```

Generate a sequence:
```rust
1..5 // [1, 5)
1..=5 // [1, 5]
'a'..='z'
```

### Numeric

```rust
let sum = 5 + 10;
let diff = 95.5 - 4.3;
let product  = 4 * 10;
let quotient = 56.7 / 32.2;
let truncated = -5 / 3; // -1, 化简为离0最近整数
let remainder = 43 % 5;
```

详见: [Appendix B - Operators and Symbols - The Rust Programming Language](https://doc.rust-lang.org/stable/book/appendix-02-operators.html)

### Integer Overflow

在 debug 模式下, 整型溢出会导致 panic; 在 release 模式下, 整型溢出会导致补码循环右移, 有如下处理办法:
-  使用 `wrapping_*` 方法在所有模式下都按照补码循环溢出规则处理，例如 `wrapping_add`
-  如果使用 `checked_*` 方法时发生溢出，则返回 `None` 值
-  使用 `overflowing_*` 方法返回该值和一个指示是否存在溢出的布尔值
-  使用 `saturating_*` 方法使值达到最小值或最大值
