# B Tree

## Definition

B 树是一种自平衡的树型结构. m 阶 B 树是二叉树的一般化, 具有如下特点[^1]:
1. 每个节点至多有 m 个子节点.
2. 除了根节点和叶子节点, 每个节点至少有 $\lceil m/2\rceil$ 个子节点. 子节点数量限制使节点可以在保留 B 树性质的同时, 拆分和合并, 让删除和插入操作成为可能.
3. 根节点至少有两个子节点, 除非树是空的 (仅有一个根节点).
4. **所有叶子节点在同一深度**.
5. 对于所有非叶子节点, 若包含 k 个子节点, 那么有 k-1 个键值. 键将子树值划分出区间, 比如节点内键 $a_{1}<a_{2}$, 那么子树 $b$ 有 $b_{1}<a_{1}<b_{2}<a_{2}<b_{3}$.

[^1]: 非 McCreight,1972 定义, 是 Knuth,1998 的改良定义. https://en.wikipedia.org/wiki/B-tree 

```
- pv: pointer to value.
- ps: pointer to subtree.

 | ps1 | k1:pv1 | ps2 | k2:pv2 | ... | ps(m-1) | k(m-1):pv(m-1) | ps(m) |
  /                /                     /                          \
subtree1        subtree2             subtree(m-1)                subtree(m)
```

叶子节点结构: 仅包含键和数据.

```
| k1:pv1 | k2:pv2 | .... | k(m-1):pv(m-1) |
```

| 节点类型   | 最少键数             | 最大键数 | 最少子节点数                                     | 最大子节点数 |
| ---------- | -------------------- | -------- | ------------------------------------------------ | ------------ |
| 空根节点   | 0                    | m-1       | 0                                                | 0            |
| 非空根节点 | 1 (新产生)                   | m-1        | 2                                                | m          |
| 内部节点   | $\lceil m/2\rceil-1$ | m-1        | $\lceil{m/2}\rceil$ | m          |
| 叶子节点   | $\lceil{m/2}\rceil-1$  | m-1        | 0                                                | 0             |

当 B 树深度增加一层时, 可存储的最大元素数量变为原本的 $m$ 倍, 指数级增长, 相比之下二叉树仅变为原来 2 倍. 由于 B 树是平衡的, 搜索/插入/删除操作的代价仅线性增长. 这使得 B 树适合存储大块数据, 被广泛应用于文件系统和数据库的实现.

## Heights

设 $h\geq -1$ 为树高度, $n\geq 0$ 为树内实体数, $m$ 为树阶数 (即节点最大子节点数).

满载的 B树实体数为 $n=m^{h+1}-1$, 所以 B树最小高度为:

$$h_{min}=\lceil{\log_{m}(n+1)}\rceil-1$$

对于内部节点, 其最小子节点数量为: $d=\lceil m/2\rceil$. 

Comer (1979) [^2] 证明 B树的最差高度为: 

$$h_{max}=\lfloor log_{d} \frac{n+1}{2}\rfloor$$

[^2]: Comer, Douglas (June 1979). "The Ubiquitous B-Tree". Computing Surveys. doi:10.1145/356770.356776.

## B+ Tree

B树的变种:
- 内部节点不存储数据, 仅叶子节点存储数据. 
- 叶节点包含一个指向下一个叶节点的指针. 加速线性访问.

B+树内部节点不存储数据 (异或指向数据的指针), 因此可相对存储更多键, 树更浅, 访问更快.

## API

| operation   |                               | worst case | average |
| ----------- | ----------------------------- | ---------- | ------- |
| `insert(k)` | 在树内插入键 k                | `O(logn)`  | `O(logn)`        |
| `delete(k)` | 在树内删除键 k (假设没有重复) | `O(logn)`  | `O(logn)`        |
| `search(k)`   | 若存在, 返回键 k 对应的值     | `O(logn)`           | `O(logn)`        |


> "the more you think about what the B in B-trees means, the better you 
> understand B-trees" -- McCreight, inventor of btree.

### Search

自顶向下搜索键值 $k$, 广度优先遍历顺序:
1. 在节点内部搜索键值 $k$, 若命中, 则返回.
2. 若无命中, 寻找键值 $a,b$, 使 $a<k<b$. 假设最右有键值 $+\infty$, 最左同理.
3. 若当前节点为叶节点, 未命中.
4. 若当前节点非叶节点, 进入 $a,b$ 之间的子节点, 重复步骤一.

定义 B-树先序(深度优先)遍历的顺序, 访问结果从小到大排列:
1. 遍历至最左子树的最左叶节点.
2. 顺序访问该叶节点内部键值, 数据量大时, 可以使用[二分查找](../排序/binary%20search.md).
3. 回退一层深度, 顺序遍历该内部节点的键和子树, 其中子树同样先序遍历. 
4. 重复步骤三至结束.

### Insertion

插入操作自底 (叶节点) 向上进行, 首先如前所述, 搜索应该插入键的叶节点.

1. 如果该叶节点键数量少于节点最大键数量 $m$, 那么插入该键 $k$, 并且保持节点内顺序正确.
2. 否则该叶节点已满, 需要将其分裂为两个节点:
	1. 选取该叶节点的中间键值 (包括新插入键值) $k_{m/2}$
	2. 小于 $k_{m/2}$ 的键值被放入左侧新节点, 大于 $k_{m/2}$ 的键值被放入右侧新节点.
	3. 将中间键值 $k_{m/2}$ 插入到该叶节点的父节点. 该操作可能引起父节点分裂; 如果该叶节点没有父节点 (即, 它就是根节点), 产生一个新根节点, 树高度增长. 
	4. 叶节点永远是叶节点, 只会分裂, 不会变为内部节点.

### Deletion

B树删除策略为: 删除元素, 重构树结构, 保持树性质.

#### delete from a leaf node

1. 搜索要删除的键值 $k$.
2. 如果键值在叶节点, 直接删除即可.
3. 删除后, 如果叶节点键值数量少于下限, 树需要重新平衡.

#### delete from an internal node

1. 搜索要删除的键值 $k$.
2. 如果键值在内部节点, 需要重新寻找新分隔符代替 $k$. 由于 $k<min(\text{right subtree})$, 这里取右子树的最小值 $k'$, 即对右子树进行*先序遍历*, 取第一个值作为新分隔符, 代替 $k$. 注意同样有 $max(\text{left subtree}) < k$.
3. 从右子树*最左叶节点*删除最小键值 $k'$, 如果此时该节点键值数量少于下限, 树需要重新平衡.

#### rebalance after deletion

B树自底向上重新平衡: 此时某个叶节点 $\alpha$ 缺少键值.
- 若 $\alpha$ 有**紧邻右侧**兄弟节点 $\beta$, 并且其有富余键值, 那么**左旋转**: 
	1. 将父节点的分隔符 $k$ 复制到 $\alpha$ 的最右侧 (末尾元素).
	2. 用 $\beta$ 最左侧元素 (首元素) 替代父节点 $k$.
- 否则, 若 $\alpha$ 有**紧邻左侧**兄弟节点 $\gamma$, 并且其有富余, 那么**右旋转**:
	1. 将父节点的分隔符 $k$ 复制到 $\alpha$ 的最左侧.
	2. 用 $\gamma$ 最右侧元素替代父节点 $k$.
- 否则, 将 $\alpha$ 和 $\beta$ **融合**: ($\gamma$ 类似).
	1. 将父节点分隔符 $k$ 复制到左侧节点 $\alpha$ 的末尾. 
	2. 将右侧节点 $\beta$ 所有元素移动到 $\alpha$ 的末尾.
	3. 删除父节点 $k$ 与右侧节点 $\beta$, 注意此时父节点损失了一个元素:
		- 如果父节点为根, 并且没有删除 $k$ 后为空, 那么 $\alpha$ 成为根.
		- 否则, 如果父节点键值数量少于下限, 依上述步骤重新平衡父节点.
- 结束条件为所有节点达到 B-树定义要求. 注意根节点没有键值数量下限.
