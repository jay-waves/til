## 网络编程


## IO 多路复用模式

在多路 IO 复用模式中，应用需要向内核（或后台程序）注册 `handler`，同时放弃阻塞等待 IO 事件。当 IO 事件发生时，内核会调用 `handler` 以唤醒注册程序。

### Reactor 

Reactor 模型中，内核将 IO 事件转发给应用，应用自行读写。如果是非阻塞读写，由于内核不知道交付目标，因此内核不保证 IO 能够完成，应用需要维护状态机。

| 单一工作线程 | 工作线程池 |
| ------------ | ------ |
|  ![\|400](../attach/reactor1.png)            | ![\|400](../attach/reactor2.png)       |

`Handler` 中，负责处理 IO 的部分，和处理业务逻辑的部分也可分离。

### Proactor 

Proactor 模型中，应用将交付目标提交给内核，内核负责 IO 操作与维护状态机，在 IO 完成后再通知应用。此时，应用可以直接获得 IO 操作的结果，是完全异步的。

Proactor 在一些场景下有优势：
* 减少内核、用户态切换。Reactor 模型下，后续*读写*也需要独立的内核调用。
* 便于批处理。IO 状态机下沉到内核，内核直接合并多个 IO 事件。

|              | Actor    |
| ------------ | -------- |
| libevent     | Reactor  |
| Netty (Java) | Reactor  |
| Windows IOCP         | Proactor |
| Linux epoll  | Reactor  |
| Linux io_uring | Proactor |
| POSIX AIO    | Proactor |
| ASIO         | Proactor |

## 网络编程性能优化

从两个方面优化性能:
- throughput. 吞吐量需要测试**一个端点**处理大量消息的性能.
- latency. 延迟需要测试**两个端点**传递消息的速度.

### Batching 

ZeroMQ 将多个消息合并为一次请求处理, 避免频繁地系统调用, 从而增加系统的吞吐量. 但*批处理 (batching)* 会增加延迟, 同一批次的最先抵达的网络包, 其延迟也最大. 最佳实践是, 当消息速率超过网络带宽 (bps, msg/s...) 时, 打开网络批处理, 避免消息排队; 批处理应在整个网络栈的尽可能上层开启, 减少整体资源开销.

TCP 中的批处理算法被称为 *Nagle's Algorithm*, 通常网络场景总有消息排队 (queueing effect), 推荐开启.

![](../../../attach/Pasted%20image%2020250503221227.avif)

![](../../../attach/Pasted%20image%2020250503221234.avif)

### 

https://aosabook.org/en/posa/high-performance-networking-in-chrome.html

D:\desktop\Open-MX-IOAT.pdf

https://aosabook.org/en/posa/secrets-of-mobile-network-performance.html

https://aosabook.org/en/posa/warp.html

### 大规模并发

1. 文件句柄数量限制. 默认为 `ulimit -n` --> 1024
2. 

## 参考

https://aosabook.org/en/v2/zeromq.html