---
source: https://tldp.org/LDP/tlk/mm/memory.html
---

## 分页技术

- 外碎片: 内存中空闲分区太小, 而难以利用
- 内碎片: 分配给进程的内存区域, 进程实际未使用

连续内存分配方法产生的内存碎片多, 而离散内存分配方法则效率相对较低. 现代操作系统采用分页技术 (paging) 来解决外碎片问题. 后来, 为了解决物理内存空间不足的问题, 分页技术逐渐和[虚拟内存](虚拟内存.md)结合.

### 分页内存管理

将物理内存分为等长块, 称为**页框 (Page Frame)**, 逻辑内存也分为同样长的块, 称为**页面 Page**, 每个页面独立编号 PFN (Page Frame Number). 以页框为单位为进程分配内存, 不会产生外碎片 (有内碎片), 32 位机器页宽为 `4KB`, 64 位为 `8KB`.

操作系统维护**空闲页框表**, 负责管理物理内存空闲页框. 维护**页表 (PT)**, 记录页面与页框的映射关系, 页表项被称为 PTE.

![|100](../../attach/Pasted%20image%2020230620195945.avif)

假设逻辑空间大小为 $2^m$ 字节, 页大小为 $2^n$ 字节. 则可以通过截取地址, 来区分页面号和业内偏移: 

```
       m-n             n
+---------------+---------------+
|  page number  |  page offset  |
+---------------+---------------+

page_offset = addr & (2^n -1);
page_number = addr >> n;
```

分页的地址转化过程如下图所示. 

![|500](../../attach/os-虚拟地址转换.avif)

注意, 若页表在内存中, 则过程需要两次访存. 有两个重要寄存器:
- 页表基址寄存器 (PTBR) 存储页表的内存位置
- 页表限长寄存器 (PRLR), 检查页面号是否越界

引入块表 (转化表缓冲区, Translation Looaside Buffer, TLB), 位置在 CPU [cache](../../arch/计算机组成/cache.md)中, 保存最近使用的地址映射, 从而加速地址转换:

![|400](../../attach/os-引入TLB的虚拟地址转换.avif)

为评价TLB效率, 引入**有效访问时间 EAT**:

$\text{EAT}=\lambda(a+b)+(1-\lambda)(a+2b)$. 其中查找 TLB 时间为 $a$, 内存存取时间为 $b$, 命中率为 $\lambda$.

### MMU

**虚拟地址和物理地址的转换, 由硬件 MMU (Memory Management Unit) 完成, 页表维护则由操作系统完成**. CPU 有专用寄存器存储**页表基地址** (x86 CR3, ARM TTBR0). 进程切换时, 内核会将新页表地址写入该寄存器, CPU MMU 硬件据此完成 PA --> VA 的映射.

1. MMU 拿到虚拟地址, 从根页表开始查表
2. MMU 解析多级页表
3. 如果缺陷或权限不符, MMU 触发 Page Fault 异常, 陷入内核.
4. 如果页表有修改, 内核负责刷新 TLB (如 ARM tlbi 指令), 告知 MMU 更新缓存.

### 分级页表

32 位系统对于每个进程都要存 4MB 页表, 占用大量**连续**内存, 大部分页表项是无用的. 因此照搬虚拟内存页表的思路, 衍生出多级页表.

![|550](../../attach/Pasted%20image%2020240507170816.avif)

硬件架构会强制规定多级页表的结构和查表方式, 以确保 MMU 的正确运行. 内核根据硬件要求, 运行时构造多级页表. 比如 linux x86_64 平台上, 使用四级页表:
 - PGD (Page Global Directory) 页全局目录
 - PUD (Page Upper Directory) 页上级目录
 - PMD (Page Middle Directory) 页中间目录
 - PTE (Page Table Entry) 页表条目

x86_64 的实际有效地址位数是 48b, 因此 PTE 位域中还定义了很多元信息:
- b0: Present/Valid
- b1: R/W 读写位
- b2: U/S 用户态
- ...
- b51-b12: 基地址
- b3: NX 不可执行位

## 虚拟内存

直接为进程分配物理内存的缺点如下:
1. 地址空间不隔离, 程序地址是全局可见的, 容易招致恶意程序攻击.
2. 内存使用效率低, 空间不够时, 需要将整个程序换入换出.
3. 程序运行地址不确定. 导致程序编写 (数据与指令跳转) 复杂.

引入虚拟内存地址技术, 即每个进程的虚拟地址空间都是隔离的完整的 (32 位下为 4GB), 由操作系统的 MMU (Memory Management Unit) 负责将虚拟地址转化为物理地址. 技术上, 装入时, 程序部分装入; 运行时, 数据换入换出, 按需调页; 当物理内存不足时, 不需要的换出.

```
CPU -- vaddr --> MMU -- paddr --> Memory
```

**分页技术是虚拟内存技术的主流实现方式.**


### 虚拟页式存储

 虚拟内存技术很自然地和分页技术结合, 扩展出如下功能:
- 按需调页, Demand Paging
- 页面置换, Swapping: 将暂时不使用的页面换出内存
- 页框分配: 为各个进程分配页框数量
- 访问控制, Access Control.

#### 按需调页

为页表增加: 有效无效位, 其中无效位有*相关页无效, 页面有效但不在内存中*两种情况. 当试图访问无效页表项时, 会产生**缺页中断, Page Fault Trap**.

![|450](../../attach/Pasted%20image%2020230621083243.avif)

为了支持按需调页, 通常在外存划分**交换区**, 交换区文件连续分配, 以支持更快读写. 其他区域称为文件区, 离散分配, 利用率高.

#### 页面置换

按需调页选中的外存页调入内存时, 若内存无空闲页框, 则按**页面淘汰算法**换出一个页, 然后调入选中页. 为了减少交换负担, 还用*脏位 dirty bit* 记录页面是否被修改, 若未被修改, 则直接丢弃.

![|400](../../attach/Pasted%20image%2020230621091127.avif)

常见页面交换算法:
- FIFO
- OPT, 最优
- LRU, 最近最少使用 (linux 使用)
- CLOCK, 时钟置换算法, 二次机会

#### 页框分配

**抖动, 颠簸, thrashing**: 一个进程页面的频繁换入换出. 产生抖动的诱因是驻留集过小, 即驻留集远小于局部 (程序最近访问页面集合). 解决办法也就是使驻留集约等于局部, 当物理内存严重不足时, 虚拟内存提供的扩存作用有限.

> 内存空间扩充的技术: 覆盖 (已淘汰), 交换, 虚拟内存

#### 访问控制

MMU 除了完成地址转换和缓存, 还根据页表条目 (PTE) 中的权限位来控制检查访问权限.
比如:
- 防止程序访问脏数据.
- 防止可执行程序内存段被写入.
- 防止可写入内存段被执行.
