## 协程

[M:N 调度模型](进程与线程.md) 认为, 用户态线程可在用户态完成调度, 而无需切换到内核态去仲裁. 一种实现方法是: 各线程在可能的阻塞位置, 主动让出 CPU 来触发调度. 

这样, 无需用时间片强制触发调度, 也无需通过锁来暂停调度. 通过编程人员的显式调度, 来约束并发任务的偏序关系. 

这种调度方式, 不适合 CPU 密集任务, 因为此类任务需要持续占用 CPU 完成计算; 而适合 IO 密集任务, 因为 IO 事件可能造成无需 CPU 参与的阻塞等待, 此时让出 CPU 是合适的. 

*协程 (Coroutine)*, 是一种**协作式** (而非抢占) 的用户态线程的概念, 它明确定义了单线程下多个任务之间执行权的交接点. 

### Event Loop

将 IO 事件挂起, 交给*事件循环 (event loop)* 追踪, 事件完成后适时触发调度, 取回执行权. 事件循环整体不会阻塞.

*挂起*和*恢复*
- 挂起: 让出 CPU, 挂起一个回调函数. 
- 恢复: 事件完成时, 触发回调函数.

### Work-stealing Pool 

Go CSP 模型

## 实例

* linux 提供 epoll 接口管理异步 IO 任务
* c 语言库 libuv，libevent 
* C++ 库 libfiber，qthreads

> 参考: https://zhuanlan.zhihu.com/p/147608872
