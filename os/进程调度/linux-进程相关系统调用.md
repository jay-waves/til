## fork()

Linux 创建新进程时, 并不完整复制原进程, 而是和原进程共享一个*写时复制 (Copy on Write, COW)* 的内存空间. 

新进程有新的 `task_struct`, 大部分原信息是复制过来的, 但内存是浅拷贝的: 虚拟内存 VMA 复制给子进程, 但不会立刻复制物理页. 所有共享的物理页 PTE 立刻被标记为只读, 清空"可写"标志, 然后更新 `struct page` 中的 `refcount`.

一旦某进程对某个只读 PTE 进行修改, 就会触发*缺页异常 (Page Fault)*, 会分配一个新的物理页, 然后把旧页复制到新页.