Unix 中动态链接文件被称为动态共享对象 (Dynamic Shared Objects, DSO), 扩展名为 `.so`; 在 Windows 上, 被称为动态链接库 (Dynamical Linking Library), 扩展名为 `.dll`. 在链接时, 动态链接库也需要输入到链接器中, 用于解析符号, 但不合并到最终目标程序内部.

动态链接由*动态链接器*进行, **将链接过程从程序装载前, 推迟到装载时**, 将程序拆分为独立模块. 动态链接比静态链接有大概 5% 的性能损失, 但是**节省了空间**并简化了程序构建. 多个模块共享同一个依赖, 也减少了 CPU 缓存的命中率.

在程序运行时, 虚拟空间中包含: 目标程序, 目标程序依赖的动态链接库 (如 `libc-xxx.so`), 动态链接器 (如 `ld-xxx.so`). 在编译时, `.so` 模块的装载地址是不确定的, 在使用时由动态链接器决定其最终装载地址; 而目标程序可以固定装载地址, 因为它是第一个被加载的, 不会地址冲突.

- 链接时重定位 (Link Time Relocation)
- 装载时重定位 (Load Time Relocation), (Windows Rebasing): 程序中包含大量绝对地址, 所有要重定位的地址记录在*重定位表*中, 如果装载时加载地址不是预期地址, 需要修改代码段对这些地址的引用. 这导致不可共享代码段, 并且代码段不是只读 (安全性差).
- 地址无关代码 (PIC, Position-independent Code) 将可能需要重定位的地址或指令独立出来, 放在数据段 GOT/PLT 中. 使用相对寻址, 在运行时通过访问 GOT/PLT 来获取实际的变量 / 函数地址. 保持代码段不变, 并且和装载地址无关, 从而多个进程可共享. 数据段各自进程持有副本.

### 地址相关指令

1. 模块内部的跳转  --> 相对寻址, 相对当前 PC 寻址
2. 模块内部的数据访问 --> 相对寻址. 先通过某种方式获取 PC 值, 然后相对 PC 跳转.
3. 模块外部的数据访问 --> 通过数据段的 GOT 进行间接寻址, 其他模块暴露的变量地址统一存放在 GOT 表中.
4. 模块外部的跳转 --> 通过数据段的 GOT 进行间接寻址, GOT 表中存储 目标函数 的地址.

## PIC

位置无关代码 (Position-Independent Code, PIC) 是动态链接的特点, 其目标是减少甚至消除在装载可执行文件时的重定位行为. 

PIC 允许多个进程共享同一共享库的代码段, 并且由于不需要重定位修改代码段中的地址, 所以加载时间更快. 每个进程有独立的数据段, 数据段中有 GOT 的独立副本.

- 内存效率高
- 加载效率快, 尤其是系统重启或进程频繁启动时.
- 安全性强, 支持*地址空间布局随机化 (ASLR)*, 防范缓冲区溢出攻击.

### GOT

全局偏移表 (Global Offset Table, GOT) 用于存储全局变量和函数的地址. 加载时, GOT 存放于数据段并动态更新. 代码段的指令要获取变量时, 不直接获取变量的绝对地址, 而是指向 GOT 中的一个位置 (存储一个偏移量). 动态链接器链接时, 将指令中变量地址 (指向 GOT) 修改为 GOT 中存储的变量绝对地址.

在 ELF 文件中, GOT 在文件中有 `.got` `.got.plt` 两个紧挨着的段. `.got` 为变量重定位服务, `.got.plt` 为函数重定位服务. 重定位的起始地址是 `.got.plt` 段的起始点, 偏移量为正值就访问 `.got.plt`, 偏移量为负值就访问 `.got`.

### PLT

C/C++ 库包含大量函数, 全部载入 GOT 会浪费大量空间和重定位开销. 因此编译器引入了*延迟绑定 (Lazy Binding)* 技术. 只有当函数被真正调用时, 才会去解析其在内存中的真实地址. 当启用延迟绑定时, GOT 一开始不会存储函数的绝对地址, 而是先存储函数在*过程链接表 (Procedure Linkage Table, PLT)* 中的位置. 过程链接表 在代码段, 因此是不可写的. 

在第一次调用 `printf` 函数时:
1. 编译器转化为调用 `printf@plt`, 是 PLT 表的某个项 `PLT[n]`.
2. 跳转到 `GOT[n]` (`PLT[n]` 的第一条指令)
	1. 在首次调用时, `GOT[n]` 没有存储 `pritnf` 函数绝对地址, 而是初始化为 `PLT[n]` 的第二条指令.
	2. 在后续调用时, `GOT[n]` 已经存储 `printf` 函数的绝对地址, 可以直接调用.
3. 将符号偏移量入栈 (`PLT[n]` 的第二条指令)
4. 跳转到 `PLT[0]` (`PLT[n]` 的第三条指令), `PLT[0]` 处会启动动态链接器. 动态链接器将解析 `printf` 函数加载在内存中的绝对地址, 将解析结果存储到 `GOT[n]` 中.


```assembly
PLT0:
	push *(GOT + 4)
	jump *(GOT + 8)

...
bar@plt:
	jmp *(bar@GOT)
	push n
	jump PLT0
```

在 `-fPIC` 模式编译的程序中, 所有函数都会使用 `GOT/PLT` 调用方式. 模块内函数调用, 也需要通过这种方式来获取模块加载地址, 再相对跳转.

## 配置动态链接器

通过 ELF 中的 `.interp` 段, 指定动态链接器. `.interp` 保存了动态链接器的地址, 如 `/lib/ld-linux.so.2`. 

ELF 中的 `.dynamic` 段存放了动态链接器的基本信息:

```c
typedef struct {
	Elf32_Sword d_tag;
	union {
		Elf32_Word d_val;
		Elf32_Addr d_ptr;
	} d_un;
} Elf32_Dyn;
```

| `d_tag`     | `d_un`            | 含义                     |
| ----------- | ----------------- | ------------------------ |
| `DT_SYMTAB` | `.dynsym`  的地址 | 动态链接符号表地址       |
| `DT_STRTAB` | `.dynstr`  的地址 | 动态链接字符串表地址     |
| `DT_STRSZ`  | `.d_val`          | 动态链接字符串表的大小   |
| `DT_HASH`   | `.hash` 的地址    | 动态链接哈希表的地址     |
| `DT_RPATH`  |                   | 动态链接共享对象搜索路径 |
| `DT_INIT`   |                   | 初始化代码地址           |
| `DT_NEED`   | 依赖文件名地址    | 依赖的共享对象文件       |
| `DT_REL`    |                   | 动态链接重定位表地址     |
| `DT_RELENT` |                   | 动态重读位表入口数量                         |

`.dynsym` 类似静态链接符号表, 字符串存储在 `.dynstr`, 还有*符号哈希表* `.hash` 用于加速符号查找.

## 动态链接过程

以 Linux 为例, 首先[通过 `execve()` 系统调用装载可执行文件](可执行文件装载.md). 对于静态链接程序, 接下来控制权移交给程序入口 (ELF 头中 `e_entry` 指定的入口); 对于动态链接程序, 此时共享库还未装载, 内核首先根据 ELF `.interp` 段装载动态链接器, 然后将控制权移交给动态链接器.

显然, **动态链接器初始化过程中, 还不能使用动态链接, 只能使用静态链接**. 因此 动态链接器, 不能使用全局变量/静态变量, 不能调用模块外函数, 不能依赖其他共享对象. 由于动态链接器本身是 `PIC` 的 (为了多进程共享, 并避免代码段重定位), 因此甚至不能使用函数调用. 动态链接器初始化的过程称之为 "自举".

完成"自举"后, 动态链接器将可执行文件和链接器本身的符号表都合并到一个符号表中, 称为 *全局符号表 (Global Symbol Table)*.

接着, 链接器解析 可执行文件 中的 ELF 信息 (文件头和 `.dynamic`) 段, 寻找其所依赖的所有共享对象. 对于每一个依赖对象, 同样解析其 ELF `headers` 和 `.dynamic` 段, 将其映射到进程空间中, 并将其符号表合并到全局符号表中. (该过程可能有符号冲突, 先来者为准)

接着, 链接器遍历所有对象的重定位表, 借助全局符号表, 将 GOT/PLT 中所有需要重定位的位置修正. 

如果是 C++ 程序, 还会有 `.init` 和 `.fini` 执行段, 用于全局/静态对象的构造和析构. 对于可执行文件, `.init/.fini` 由程序初始化代码负责执行; 对于共享对象文件, `.init/.fini` 由链接器负责执行. 

### 显式运行时链接

*显式运行时链接 (Explicit Runtime Linking)*, 也叫*运行时加载*. 可以在运行时加载模块, 并适时将其卸载. 

```c
#include <dlfcn.h>

/*
	flag:
	RTLD_LAZY: 延迟绑定, 即 PLT 
	RTLD_NOW: 加载时, 立即完成所有函数绑定工作

	dlopen 不会自动处理依赖, 需要编程人员手动按依赖顺序导入所有动态库.
	dlopen 会执行 `.init` (如果有)
	dlopen 允许重复加载同一个模块, 内部会有一个引用计数.

	返回值: 被加载模块的句柄, 或 NULL (如果加载失败).
*/
void* dlopen(const char *filename, int flag);

/*
	通过该函数查找符号. symbol 是一个 C 字符串.
	* 如果符号是函数, 返回函数地址
	* 如果符号是变量, 返回变量地址
	* 如果符号是常量, 返回常量值
	* 返回值不能用来判断是否解析成功, 因为正常返回值可能是 NULL/0 
*/
void* dlsym(void* handle, char *symbol);

/*
	用于判断 dlsym 是否解析成功. 
	- 返回 NULL, 代表成功
	- 返回字符串, 代表错误信息
*/
char* dlerror();

/*
	模块引用计数减一, 若归零则彻底卸载.
*/
void dlclose(const char *filename);
```