Unix 中动态链接文件被称为动态共享对象 (Dynamic Shared Objects, DSO), 扩展名为 `.so`; 在 Windows 上, 被称为动态链接库 (Dynamical Linking Library), 扩展名为 `.dll`.

动态链接由*动态链接器*进行, **将链接过程从程序装载前, 推迟到装载时**, 将程序拆分为独立模块. 动态链接比静态链接有大概 5% 的性能损失, 但是**节省了空间**并简化了程序构建.

## PIC

位置无关代码 (Position-Independent Code, PIC) 是动态链接的特点, 其目标是减少甚至消除在装载可执行文件时的重定位行为. PIC 使用相对地址来代替原本代码中的绝对地址, 从而让代码在任意内存位置运行. 

PIC 允许多个进程共享同一共享库的代码段, 并且由于不需要重定位修改代码段中的地址, 所以加载时间更快. 每个进程有独立的数据段, 数据段中有GOT的独立副本.

- 内存效率高
- 加载效率快, 尤其是系统重启或进程频繁启动时.
- 安全性强, 支持*地址空间布局随机化 (ASLR)*, 防范缓冲区溢出攻击.

### GOT

全局偏移表 (Global Offset Table, GOT) 用于存储全局变量和函数的地址. 加载时, GOT 存放于数据段并动态更新. 代码段的指令要获取变量时, 不直接获取变量的绝对地址, 而是指向 GOT 中的一个位置 (存储一个偏移量). 动态链接器链接时, 将指令中变量地址 (指向 GOT) 修改为 GOT 中存储的变量绝对地址.

在 ELF 文件中, GOT 在文件中有 `.got` `.got.plt` 两个紧挨着的段. `.got` 为变量重定位服务, `.got.plt` 为函数重定位服务. 重定位的起始地址是 `.got.plt` 段的起始点, 偏移量为正值就访问 `.got.plt`, 偏移量为负值就访问 `.got`.

### PLT

C/C++ 库包含大量函数, 全部载入 GOT 会浪费大量空间和重定位开销. 因此编译器引入了*延迟绑定 (Lazy Binding)* 技术. 只有当函数被真正调用时, 才会去解析其在内存中的真实地址. 当启用延迟绑定时, GOT 一开始不会存储函数的绝对地址, 而是先存储函数在*过程链接表 (Procedure Linkage Table, PLT)* 中的位置. 过程链接表 在代码段, 因此是不可写的. 

在第一次调用 `printf` 函数时:
1. 编译器转化为调用 `printf@plt`, 是 PLT 表的某个项 `PLT[n]`.
2. 跳转到 `GOT[n]` (`PLT[n]` 的第一条指令)
	1. 在首次调用时, `GOT[n]` 没有存储 `pritnf` 函数绝对地址, 而是初始化为 `PLT[n]` 的第二条指令.
	2. 在后续调用时, `GOT[n]` 已经存储 `printf` 函数的绝对地址, 可以直接调用.
3. 将符号偏移量入栈 (`PLT[n]` 的第二条指令)
4. 跳转到 `PLT[0]` (`PLT[n]` 的第三条指令), `PLT[0]` 处会启动动态链接器. 动态链接器将解析 `printf` 函数加载在内存中的绝对地址, 将解析结果存储到 `GOT[n]` 中.


```assembly
PLT0:
	push *(GOT + 4)
	jump *(GOT + 8)

...
bar@plt:
	jmp *(bar@GOT)
	push n
	jump PLT0
```
