在链接中, 将函数和变量统称为**符号 (symbol)**, 函数名和变量名称为**符号名 (symbol name)**. 当目标文件 B 使用目标文件 A 定义的符号 `foo()`, 此时需要有对该符号的**引用 (reference)**. 

每个目标文件维护着一个**符号表 (symbol table)**, 记录了其中的所有符号. 符号的索引地址被称为**符号值 (symbol value)**. 符号有几种分类:
- 定义在本目标文件的全局符号. 
- 局部符号. 对其他目标文件不可见, 因而链接过程无作用.
- 在本目标文件中引用的全局符号, 未在本目标文件定义. 称为**外部符号**
- 段名. 如 `.text`.

### ELF符号表

ELF 文件中的符号表叫 `.symtab`, 是 `struct Elf32_Sym[]`. 惯例数组第一个元素为 `NULL`, 即未定义符号.

```c
typdef struct {
	Elf32_Word st_name; // index of symbol name in .strtab
	/*
	 * symbol value 
		 * offset in local seciton, if not st_shndx != SHN_COMMON.
		 * alignment, if st_shndx == SHN_COMMON.
		 * virtual address, if elf is executable.
	 */
	Elf32_Addr st_value; 
	Elf32_Word st_size; // size of type of symbol. 8(bytes) for double.
	/* 
	 * symbol type (low 4 bits)
		 * STB_LOCAL, 0, local symbols 
		 * STB_GLOBAL, 1, global symbols
		 * STB_WEAK, 2, weak reference
	 * symbol binding (high 28 bits)
		 * STT_NOTYPE, 0, unknown or undefined.
		 * STT_OBJECT, 1, data object like arr[] or var.
		 * STT_FUNC, 2, funciton or executable code
		 * STT_SECTION, 3, section of ELF. has to be STB_LOCAL
		 * STT_FILE, 4, name of source file. has to be STB_LOCAL
	 */
	unsigned char st_info; 
	...
	/* 
	 * SHN_ABS, 0xfff1, like source files (STT_FILE)
	 * SHN_COMMON, 0xfff2, like uninitialized global symbol.
	 * SHN_UNDEF, 0, undefined symbol
	 * other, local section this symbol belongs to
	 */
	Elf32_Half st_shndx; // elf section this symbol belongs
} Elf32_Sym;
```

#### 实例

注意 `Ndx` 字段, 数字代表其所属的 ELF 段. 如 `main` 符号属于 `.text` 代码段.

```bash
> readelf -s test_elf.o

Symbol table '.symtab' contains 13 entries:
   Num:    Value          Size Type    Bind   Ndx  Name
     0: 0000000000000000     0 NOTYPE  LOCAL  UND
     1: 0000000000000000     0 FILE    LOCAL  ABS  test_elf.c
     2: 0000000000000000     0 SECTION LOCAL  1    .text
     3: 0000000000000000     0 SECTION LOCAL  3    .data
     4: 0000000000000000     0 SECTION LOCAL  4    .bss
     5: 0000000000000000     0 SECTION LOCAL  5    .rodata
     6: 0000000000000004     4 OBJECT  LOCAL  3    static_var.1
     7: 0000000000000004     4 OBJECT  LOCAL  4    static_uninit_var.0
     8: 0000000000000000     4 OBJECT  GLOBAL 3    global_init_var
     9: 0000000000000000     4 OBJECT  GLOBAL 4    global_uninit_var
    10: 0000000000000000    43 FUNC    GLOBAL 1    func1
    11: 0000000000000000     0 NOTYPE  GLOBAL UND  printf
    12: 000000000000002b    55 FUNC    GLOBAL 1    main
```

> `test_elf.c` 具体定义见 [ELF目标文件](ELF目标文件.md)

### 工具

查询符号表工具有: `readelf -s`, `objdump`, `nm`

### 符号冲突

多模块目标文件的符号名可能重复, C 语言提供一些作用域限定符 (`extern, static`) 来限制符号污染, C++ 则提供了命名空间 (namespace) 和符号改编 (name mangling) 机制. 

C++ 扩展了 C 语言的**函数签名 (function signature)**, 以准确识别函数符号, 其内容包括: 函数名, 参数类型, 命名空间, 所属类. 函数签名不同, 函数即不同, 符号不会冲突, 被称为 C++ **函数重载**.

```cpp
int func(int);
float func(int);
class C {
	int func(int);
	class C2 {
		int func(int);
	};
};

namespace N {

int bar;
int func(int);
class C {
	int func(int);
};

} // namespace N
```

在底层编译时, C++ 会对函数签名进行修饰, 形成独特的符号名, 称为符号改编. *注意, 符号改编不考虑返回值, 也不考虑变量类型*. 考虑仅有返回值不同的两个 `func()`, 由于 C 具有隐式类型转换, 对 `func()` 的调用不能仅凭返回类型来确定.

| 函数签名[^1]           | g++ 符号改编后    |
| ---------------------- | ----------------- |
| `int func(int)`        | `_Z4funci`        |
| `float funct(int)`     | `_Z4funcf`        |
| `int C::func(int)`     | `_Z41C4funcEi`    |
| `int C::C2::func(int)` | `_ZN1C2C24funcEi` |
| `int N::func(int)`     | `_ZN1N4funcEi`    |
| `int N::C::func(int)`  | `_ZN1N1C4funcEi`  |
| `bar`                  | `_ZN1N3barE`                  |

[^1]: 例子来源于 *程序员的自我修养--链接, 装载与库*, 俞甲子等, P88.

g++[^2] 符号改编基本规则如下.
- 普通符号 `_Z` 开头; 嵌套符号路径以 `_ZN` 开头, `E` 结尾.
- 后续路径名称为*作用域名称长度+作用域名称*
- 符号路径后是参数列表, 如 `int -> i`, `string -> Ss`, `long -> l`

### extern "C"

C++提供了 `extern "C"` 关键词来导出 C 符号, 而不使用 C++ 的符号改编方式. 常用于和 C 语言兼容.

```c
extern "C" {
	int func(int);
	int var;
}

extern "C" int func(int);
```

当 C 和 C++ 公用一套头文件时, 为了避免导出符号不一致, 常用办法为:

```c
// g++ will define __cplusplus for c++ programs.
#ifdef __cplusplus 
extern "C" {
#endif

void *memset (void *, int, size_t);

#ifdef __cplusplus
}
#endif
```

[^2]: 不同编译器的符号改编规则可能不同, 可使用 `c++filt` 等工具反解析符号.
