

```
f()
```

对于非内联函数, 编译器会将机器码存放在目标文件中, 并创建一个相关联的符号:
- 对于 C, 该符号就是函数名本身
- 对于C++, 由于支持函数重载, 所以函数名后还要加上其参数类型的编码. 称为 mangeld name

调用函数 `f()` 时, 也有两种方式:
1. 直接调用, 该函数地址是指令的一部分. 直接调用效率比间接调用高许多.
2. 间接调用, 该函数地址存放在内存或寄存器某处

编译进行时, 编译器可能仅知道函数名称(声明), 而暂时不知道函数 `f()` 的地址, 此时会先生成一地址未确定的直接调用指令. 链接器会负责更新上述调用指令, 因为所有目标文件都是对其可见的.

但若编译器连函数名称都不知晓 (如函数指针), 就仅能用间接调用. 如:

```c
void foo (void (*pf)() )
{
    pf(); // 通过函数指针进行间接调用
}
```

此时编译器和链接器都束手无策, 只能到代码运行时才能确认具体调用目标. 

***

现代计算机中, 函数调用指令仍是一个性能障碍. 考虑如下代码: 编译器即使看到了 `param` 的 `const` 属性, 也不能确定这个属性是不会变的. 同理, 由于全局指针的存在, 编译器也不能假设 `f3` 作用域不会修改 `param` 的值. 因为在编译时无法确认函数具体行为 (因为函数具体定义此时可能不可见), 编译器无法假设 `param` 为常量将其放入寄存器中, 而只能将其放入内存中, 拖慢了执行速度.

```cpp
int f1(int const& r)
{
	// 通过 C 式类型转化, 去掉 const 属性
	// 这非常不合理, 但是却合法....
    return ++(int&)r; 
}

int f2(int const& r)
{
    return r;
}

int f3()
{
    return 42;
}

int foo()
{
    int param = 0;
    int answer = 0;
    f2(param);
    f3();
    return answer + param;
}
```

若 `f1,f2,f3` 皆声明为内联函数, 那么 `foo()` 可等价于如下, **内联可以避免函数调用开销, 并且能让优化器看到函数作用域对外部变量进行的操作.**

```cpp
int foo_ex()
{
    int param = 0;
    int answer = 0;
    answer = ++(int&)param;
    return answer+param;
}
```

编译器马上将上述代码优化如下. 当然, 内联可能导致机器码膨胀的问题, 应保持简单.

```c
int foo_ex() 
{  
     return 2; 
}
```

***

推荐一般函数的定义和声明分离, 因为在头文件中定义函数可能导致链接时重复定义风险: 多个源文件包含该头文件, 每个源文件皆有一个函数副本, 目标文件有多个重复函数实例.

内联函数和模板函数推荐定义在程序头文件 (`.h`) 中, 因为编译器会将其代码直接实例化, 而不是等待到链接时再确认.
