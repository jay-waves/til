## 复杂度分析

数据结构和算法的核心需求是: 让程序更快, 同时更节省存储空间. 要衡
量这两个指标, 一种方法是 `profiling`,  即不断运行该程序并监控性
能和内存, 这种方法不够"理想", 影响因素多; 另一种方法就是 **复杂
度分析**: 用 `n` 模拟数据规模, 此时程序的时间或空间用量可表示为
 `f(n)`. 当 `n` 规模足够大时, 我们仅关心 `f(n)` 的*等价无穷大*, 
即: $O(f(n))$

举例而言, 下述程序的时间复杂度为 $O(n^{2})$:
```c
for (i = 0; i < n; ++i) {
	for (j = 0; j <= n; ++j) {
		...
	}
}
```

复杂度为 $O(log_{2}(n))$ 的程序:

```c
i = 1;
while (i <= n) {
	i = i * 2;
}
```

复杂度为 $O(m+n)$ 的程序, 取决于 $m, n$ 的规模:

```c
for(i = 0; i < n; ++i)
	...

for(i = 0; i < m; ++i)
	...
```

### 最好与最坏情况时间复杂度

对于存在概率性分支的代码, 运行时间不固定, 存在最好与最坏执行情况, best/worst case time complexity. 

下面的样例代码在数组中查找值, 最好情况, `arr` 第一个元素就是 `x`, 立即返回, 即 `O(1)` 时间; 最坏情况, `arr` 没有 `x`, 一直遍历到结束, 用时 `O(n)`.

```c
int find(int[] arr, int n, int x) 
{
	...
	for (i = 0; i < n; ++i) 
		if (arr[i] == x)
			return i;
}
```

### 平均情况时间复杂度

上述各种执行情况时间的加权平均, 就是平均时间复杂度, average case time complexity. 对于上面的例子, 为 $O\left( \frac{n}{2} \right)\sim O(n)$, 假设每个元素为 `x` 的概率相同.

### 均摊时间复杂度

**摊还分析**的结果称为**均摊时间复杂度**, amortized time complexity. 对数据结构进行一系列*连续*操作, 大部分操作时间复杂度低, 个别操作时间复杂度高, 此时摊还分析尝试能否将较高时间复杂度的操作的耗时平摊到其他低时间复杂度的操作上, 从而降低整体的时间复杂度.

...