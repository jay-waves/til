### ROS2 系统简介


![|500](../../attach/Pasted%20image%2020240323154317.png)

### ROS2 节点注册

在 ROS 2的体系结构中，节点（Node）是最基本的执行单位，负责特定功能的实现，
如数据处理或硬件接口。每个节点可以包含多种通信机制，包括订阅者（Topic 
Subscribers）、定时器（Timer）、服务服务器（Service Servers）和服务客户端
（Service Clients）。这些通信实体的目的是为了接收和发送数据，以及提供不同的服务。

节点注册到执行器（Executor）中，执行器是一个控制实体，负责协调节点的活动。
当节点的一个通信事件发生时，比如收到一个主题消息或服务请求，执行器会调用相应的处
理函数，或称为回调函数（Callback）。这些回调函数是预先定义的，用来响应特定类型的
事件，如 `topic_receive()` 用于处理主题消息，`request_receive()`用于处理服务请求，
`time_up()`用于处理定时器完成计时。

在节点的生命周期中，可以使用生命周期状态机（Lifecycle SM）来管理节点的状态，
这在管理复杂节点时特别有用。生命周期状态机允许节点在不同状态之间转换，如激活
（activate）、去激活（deactivate）和清理（cleanup）。每个状态变化都可以有对应
的回调函数，例如`on_setting()`在节点激活时调用，用于声明节点接口、节点执行器
（Executor）、通信订阅和服务订阅等一系列节点功能实体；`on_activate()` 用于节点
初始化完毕开始服务，此时节点处于正常工作状态； `on_cleanup()`在节点清理资源时
调用，用于释放节点所持有的微机资源。

```
spin():
	while True:
		new_msg <- ros_dds_listener()
		handler <- get_callback(new_msg)
		Executor.execute(*handler)
		sleep(0.1)
```

节点调用 spin() 函数来持续检查和处理事件，如上述伪代码。`spin()` 实质是一种事件
循环，它会保持节点循环和监听，检查系统中是否有新的ROS消息或待处理的消息，获取到
消息实体后，根据消息类型获取节点初始化时注册的回调函数，交付给节点执行器去执行，
从而完成对该事件（消息）的响应。`spin()`函数是一个事件循环，保持节点持续运行并
相应事件。

在执行器内部，`execute_any_*()` 函数是对ROS核心细节的抽象，这个函数根据事件的类
型和优先级选择一个事件来处理。处理过程包括执行注册的回调函数，这些函数是在节点初
始化时注册的，如`timer.registe_handler()` 用于注册定时器事件的回调；`subscriber.regeste_handler()` 用来注册监听到某话题时触发的回调函数，以处理该数据。

总体而言，ROS2的程序机制基于事件驱动的模型，通过节点、执行器和回调函数协同工作来
响应和处理各种事件，这些事件可能来源于数据的接收、定时器的触发、服务的请求和响应，
以及节点生命周期状态的变化。通过这种灵活且模块化的设计，ROS 2能够支持复杂且多样化
的机器人系统开发。

> executor本身是没有状态的，所以直到节点句柄释放之前，它一直在`spin()`，此时收到外部信息
> 还是可能执行回调函数。如果此时已经到了句柄释放阶段，其释放顺序错误可能导致关闭期间的UAF等数据竞争错误。
> 各个callback可能共享内存，所以可能发生常规并发bugs

### ROS2 节点释放

为了处理节点的正确初始化、有序节点关闭释放，ROS2引入了节点生命周期状态机（Lifecycle
State Machine）来管理节点生命周期的转换和执行。当ROS2系统的节点将释放时，节点的
生命周期状态机会从 activate 状态转换为 deactivate 状态，此状态仅用于让节点完成必
要的最后工作，如完成正在处理的数据传输或请求，然后进入非活跃状态。

紧接着，节点生命周期状态机转为 cleanup 状态，调用 `on_cleanup()` 回调函数来释放节点
拥有的资源，这包括所有回调函数（callback handlers），如和话题订阅、定时器、服务等回调
函数。然后清理节点所打开的文件，断开网络连接，释放ROS2上下文，最终释放内存。

> 由于 handler 用 shared_ptr 实现，所以 Exectuor 未释放时可能 UAF 
